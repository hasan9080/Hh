---
reviewers:
- Babapool
- divya-mohan0209
title: कंटेनर जीवनचक्र हुक
content_type: concept
weight: 40
---

<!-- overview -->

यह पृष्ठ वर्णन करता है कि कैसे kubelet कंटेनरों को संभालता है। 
उनके प्रबंधन जीवनचक्र के दौरान घटनाओं द्वारा ट्रिगर किए गए कोड को चलाने के लिए 
जीवनचक्र हुक फ़्रेमवर्क का उपयोग करता है।


<!-- body -->

## अवलोकन

जेसे कई प्रोग्रामिंग लैंग्वेज के फ्रेमवर्क के पास एंगुलर जेसे कंपोनेंट्स जीवनचक्र के हुक होते हैं, 
वेसे ही कुबेरनेट्स कंटेनरों को जीवनचक्र हुक प्रदान करता है। 
हुक कंटेनरों को उनके प्रबंधन जीवनचक्र में घटनाओं से अवगत होने में सक्षम बनाते हैं, 
और संबंधित जीवनचक्र हुक निष्पादित होने पर हैंडलर में कोड चलाते हैं।


## कंटेनर हुक

दो हुक जो कंटेनरों के संपर्क में होते हैं:

'PostStart'
कंटेनर बनने के तुरंत बाद इस हुक को चालू किया जाता है। 
हालांकि, इस बात की कोई गारंटी नहीं है कि हुक कंटेनर ENTRYPOINT से पहले चालू होगा। 
हैंडलर को कोई पैरामीटर नहीं दिया जाता।
'PreStop'

एपीआई रिक्वेस्ट या प्रबंधन के स्टार्टअप जांच मे विफलता, पूर्वावलोकन, संसाधन विवाद और 
अन्य जैसी घटनाएं के कारण कंटेनर समाप्त होने से तुरंत पहले इस हुक को रिक्वेस्ट भेजी जाती है।
यदि कंटेनर पहले से ही समाप्त या पूर्ण अवस्था में है तो 'PreStop' हुक की कॉल विफल हो जाती है, 
और कंटेनर को रोकने के लिए TERM सिग्नल भेजे जाने से पहले हुक को पूरा करना होता है। 
पॉड की समाप्ति 'PreStop' हुक के खत्म होने से पहले ही ग्रेस पीरियड काउंटडाउन की शुरूआत हो जाती है। 
इसलिए परिणाम की परवाह किए बिना हैंडलर, कंटेनर अंततः पॉड की समाप्ति की अवधि से पहले ही समाप्त हो जाता है, 
और इसलिए कोई पैरामीटर हैंडलर को नही भेजा जाता है।

इस समाप्ति वाले व्यवहार का अधिक विस्तृत विवरण यहाँ 
[पॉड्स का समाप्त होना](/hi/docs/concepts/workload/pods/pod-lifecycle/#pod-termination) में पाया जा सकता है।


### हुक हैंडलर कार्यान्वयन

कंटेनर उस हुक के लिए एक हैंडलर को लागू और पंजीकृत करके उस तक पहुंच सकते हैं। 
दो प्रकार के हुक हैंडलर हैं, जिन्हें कंटेनरों के लिए लागू किया जा सकता है:

* Exec - कंटेनरों के सीग्रुप और नेमस्पेस के अंदर 'pre-stop.sh' जैसे एक विशिष्ट कमांड को चलाता है।
  कमांड द्वारा उपभोग किए गए संसाधनों को कंटेनर के खिलाफ गिना जाता है।
* HTTP - कंटेनर पर एक विशिष्ट एंड-पॉइंट के खिलाफ एक HTTP रिक्वेस्ट निष्पादित करता है।


### हुक हैंडलर निष्पादन

जब एक कंटेनर जीवनचक्र के प्रबंधन हुक को कॉल किया जाता है, 
तो कुबेरनेट्स प्रबंधन प्रणाली हुक के अनुसार हैंडलर को निष्पादित करती है। 
'httpGet' और 'tcpSocket' को kubelet की प्रक्रिया द्वारा चलाया जाता है, 
और कंटेनर में 'exec' निष्पादित किया जाता है।

हुक हैंडलर, कॉल कंटेनर युक्त पॉड के संदर्भ में सिंक्रोनस होते हैं। 
इसका मतलब है कि 'PostStart' हुक के लिए, कंटेनर ENTRYPOINT और हुक फायर असिंक्रोनस होते हैं। 
हालांकि, अगर हुक को चलने में बहुत लंबा समय लगता है, तो कंटेनर 'running' की स्थिति तक नहीं पहुंच सकता।

कंटेनर को रोकने के लिए सिग्नल से 'PreStop' हुक को असिंक्रोनस रूप से चलाया नहीं जाता है; 
हुक का होना आवाशक होता है। TERM सिग्नल भेजे जाने से पहले इसका निष्पादन पूरा करना जरुरी होता है, 
यदि 'PreStop' हुक हैंग हो तो निष्पादन पॉड का चरण 'Terminate' होगा, 
और तब तक वहां रहेगा जब तक कि पॉड इसके बाद मारा नहीं जाता, 'terminationGracePeriodSeconds' की समय सीमा समाप्त होने तक।

यह छूट अवधि कुल समय पर लागू होती है 
निष्पादित करने के लिए 'PreStop' हुक और कंटेनर को सामान्य रूप से रोकने के लिए दोनों यदि, 
उदाहरण के लिए, 'terminationGracePeriodSeconds' 60 है, और हुक को पूरा होने में 55 सेकंड लगते हैं, 
और कंटेनर सिग्नल प्राप्त करने के बाद सामान्य रूप से रुकने में 10 सेकंड लेता हैं, तो फिर कंटेनर को मार दिया जाएगा, 
इससे पहले कि यह सामान्य रूप से रुक सके। क्योंकि 'terminationGracePeriodSeconds' कुल समय से कम होता है, 
इसे (55+10) समय इन दो चीजों को होने में लगता है।

यदि या तो 'PostStart' या 'PreStop' हुक विफल हो जाता है, तो यह कंटेनर को भी ख्त्म कर देता है। 
उपयोगकर्ताओं को अपने हुक हैंडलर को यथासंभव हल्का बनाना चाहिए। 
हालांकि, कभी-कभी, लंबे समय तक चलने वाले कमांड भी उपयोगी होते हैं, 
जैसे कि कंटेनर को रोकने से पहले उसके स्टेट को सहेजते समय।


### हुक डिलीवरी की गारंटी

हुक डिलीवरी का उद्देश्य *कम से कम एक बार* होना है, जिसका अर्थ है कि 
किसी भी घटना के लिए एक हुक को कई बार बुलाया जा सकता है, जैसे 'PostStart' या 'PreStart' के लिए। 
इसे सही ढंग से संभालना हुक पर निर्भर है।

आम तौर पर, केवल एक तरफ से रिक्वेस्ट कॉल की जाती हैं। 
यदि, उदाहरण के लिए, एक HTTP हुक रिसीवर ठीक से चल नही रहा और ट्रैफ़िक लेने में असमर्थ है, 
तो पुन्ह रिक्वेस्ट भेजने का कोई प्रयास नहीं किया जायेगा। कुछ दुर्लभ मामलों में, हालांकि, डबल डिलीवरी हो सकती है। 
उदाहरण के लिए, यदि एक हुक भेजने के बीच में एक kubelet पुनरारंभ होता है, 
तो kubelet के वापस आने के बाद हुक उसे वापस भेज सकता है।


### हुक हैंडलर को डीबग करना

हुक हैंडलर के लिए लॉग, पॉड की घटनाओं में उजागर नहीं होते हैं। 
यदि कोई हैंडलर किसी कारण से विफल हो जाता है, तो यह उस घटना को प्रसारित करता है। 
'PostStart' के लिए, यह 'FailedPostStartHook' इवेंट है, और 'PreStop' के लिए, 
यह 'FailedPreStopHook' इवेंट है। स्वयं विफल 'FailfailPostStartHook' इवेंट को जनरेट करने के लिए, 
[lifecycle-events.yaml](https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/lifecycle-events.yaml) 
फ़ाइल को संशोधित करें, ताकि postStart कमांड को "badCommand" में परिवर्तित किया जा सके और इसे लागू किया जा सके। 
यहां परिणामी घटनाओं का कुछ उदाहरण दिया गया है, जिन्हें आप 
`kubectl describe pod lifecycle-demo` चलाने से देख सकते हैंं:


```
Events:
  Type     Reason               Age              From               Message
  ----     ------               ----             ----               -------
  Normal   Scheduled            7s               default-scheduler  Successfully assigned default/lifecycle-demo to ip-XXX-XXX-XX-XX.us-east-2...
  Normal   Pulled               6s               kubelet            Successfully pulled image "nginx" in 229.604315ms
  Normal   Pulling              4s (x2 over 6s)  kubelet            Pulling image "nginx"
  Normal   Created              4s (x2 over 5s)  kubelet            Created container lifecycle-demo-container
  Normal   Started              4s (x2 over 5s)  kubelet            Started container lifecycle-demo-container
  Warning  FailedPostStartHook  4s (x2 over 5s)  kubelet            Exec lifecycle hook ([badcommand]) for Container "lifecycle-demo-container" in Pod "lifecycle-demo_default(30229739-9651-4e5a-9a32-a8f1688862db)" failed - error: command 'badcommand' exited with 126: , message: "OCI runtime exec failed: exec failed: container_linux.go:380: starting container process caused: exec: \"badcommand\": executable file not found in $PATH: unknown\r\n"
  Normal   Killing              4s (x2 over 5s)  kubelet            FailedPostStartHook
  Normal   Pulled               4s               kubelet            Successfully pulled image "nginx" in 215.66395ms
  Warning  BackOff              2s (x2 over 3s)  kubelet            Back-off restarting failed container
```


## {{% heading "whatsnext" %}}

* [कंटेनर पर्यावरण](/hi/docs/concepts/containers/container-environment/) के बारे में अधिक जानें।
* स्वयं कर के देखे
  [कंटेनर जीवनचक्र घटनाओं में संचालकों को जोड़ना](/docs/tasks/config-pod-container/attach-handler-lifecycle-event/)।
