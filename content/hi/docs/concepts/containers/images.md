---
title: इमेजेज (Images)
content_type: concept
weight: 10
hide_summary: true # Listed separately in section index
---

<!-- overview -->

एक कंटेनर इमेज बाइनरी डेटा को दर्शाती है जो एक एप्लिकेशन और उसकी सभी सॉफ्टवेयर डिपेंडेंसियों को एनकैप्सुलेट करता है। कंटेनर इमेजेज स्वतंत्र रूप से चल सकने वाले सॉफ्टवेयर बंडल होते हैं जो अपने रनटाइम एनवायरनमेंट के बारे में बहुत अच्छी परिभाषा करते हैं।

आप अपने एप्लिकेशन की एक कंटेनर इमेज बनाते हैं और इसे रजिस्ट्री में पुश करते हैं पहले इससे संबंधित करते हुए {{< glossary_tooltip text="पॉड" term_id="pod" >}}।

यह पृष्ठ कंटेनर इमेज कॉन्सेप्ट की एक आउटलाइन प्रदान करता है।


{{< note >}}
यदि आप कुबरनेटीज़ रिलीज के लिए कंटेनर इमेज ढूंढ रहे हैं (जैसे v{{< skew latestVersion >}}, नवीनतम माइनर रिलीज), तो [कुबरनेटीज़ डाउनलोड](https://kubernetes.io/releases/download/) करें पर जाएं।
{{< /note >}}

<!-- body -->

## इमेज के नाम


कंटेनर इमेजेज आमतौर पर `pause`, `example/mycontainer`, या `kube-apiserver` जैसे नाम दिए जाते हैं।
इमेजयों में एक रजिस्ट्री होस्टनाम भी शामिल हो सकता है; उदाहरण के लिए: `fictional.registry.example/imagename`,
और संभवतः एक पोर्ट नंबर भी हो सकता है; उदाहरण के लिए: `fictional.registry.example:10443/imagename`।

यदि आप एक रजिस्ट्री होस्टनाम निर्दिष्ट नहीं करते हैं, तो कुबरनेटीज़ कुबेरनेटीज़ को मानते हैं कि आपका मतलब डॉकर सार्वजनिक रजिस्ट्री है।

इमेज नाम भाग के बाद आप टैग जोड़ सकते हैं (जैसा कि आप दृष्टिगत कमांड का उपयोग करते हुए करेंगे
`docker` या `podman`). टैग आपको एकीकृत इमेज सीरीज के विभिन्न संस्करणों की पहचान करने देते हैं।



इमेज टैग कम से कम अक्षरों के लिए निम्नलिखित चरित्रों में से किसी एक का उपयोग करते हुए बनाए जाते हैं: छोटे और बड़े अक्षर,
अंक, अंडरस्कोर (_), डॉट (.) और डैश (-)। इमेज टैग के भीतर विभाजक वर्णों (_, -, और .) को कहाँ रखा जा सकता है
इसके लिए अतिरिक्त नियम होते हैं। यदि आप टैग निर्दिष्ट नहीं करते हैं, तो कुबेरनेट्स आपका मतलब `latest` टैग से मानता है।



## इमेज अपडेट करना

जब आप पहली बार एक {{< glossary_tooltip text="Deployment" term_id="deployment" >}},
{{< glossary_tooltip text="StatefulSet" term_id="statefulset" >}}, Pod या किसी अन्य ऑब्जेक्ट को
बनाते हैं जो एक पॉड टेम्पलेट शामिल करता है, तो दरअसल उस पॉड में सभी कंटेनरों की खींचने की नीति डिफ़ॉल्ट रूप से `IfNotPresent`
पर सेट की जाती है अगर यह उज्ज्वल रूप से निर्दिष्ट नहीं है। यह नीति कुबेलेट को इमेज को छोड़ने के लिए प्रेरित करती है अगर वह पहले से
मौजूद होता है।


### इमेज खींचने की नीति

`imagePullPolicy` एक कंटेनर के लिए तथा इमेज की tag को कैसे आधार बनाता है कि कब [कुबलेट](/docs/reference/command-line-tools-reference/कुबलेट/) निर्दिष्ट इमेज को पुल (डाउनलोड) करने का प्रयास करेगा।

यहाँ `imagePullPolicy` के लिए आप सेट कर सकते हैं वैल्यूज़ की एक सूची है तथा इन वैल्यूज़ के प्रभाव इस प्रकार हैं:

`IfNotPresent`
: यदि इमेज स्थानीय रूप से पहले से मौजूद नहीं है तो इमेज केवल पुल होगा।

`Always`
: हर बार जब कुबलेट एक कंटेनर लॉन्च करता है, तब कुबलेट कंटेनर इमेज रजिस्ट्री से नाम को इमेज के [digest](https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier) में रूपांतरित करता है।
यदि कुबलेट एक इमेज को इस बिल्कुल समान डाइजेस्ट के साथ कैश करता है, तो कुबलेट इसका उपयोग करता है; अन्यथा, कुबलेट निर्धारित डाइजेस्ट के साथ इमेज को पुल करता है, और उस इमेज का उपयोग करता है कंटेनर लॉन्च करने के लिए।

`Never`
: कुबलेट इमेज को लाने का प्रयास नहीं करता। यदि इमेज किसी तरह से पहले से ही स्थानीय रूप से मौजूद है, तो कुबलेट कंटेनर शुरू करने का प्रयास करता है; अन्यथा, स्टार्टअप असफल हो जाता है। अधिक विवरण के लिए [पूर्व-खींची](#pre-pulled-images) इमेजयों को देखें।


अंतर्निहित इमेज प्रदाता की कैशिंग सेमांटिक्स ने भी सुनिश्चित किया है कि जब तक रजिस्ट्री विश्वसनीय रूप से उपलब्ध हो, `imagePullPolicy: Always` भी अधिक दक्ष होता है। आपके कंटेनर रनटाइम को यह पता लगा सकता है कि इमेज लेयर पहले से ही नोड पर मौजूद हैं, ताकि वे फिर से डाउनलोड नहीं करने हों।

{{< note >}}
आपको उत्पादन में कंटेनर डिप्लॉय करते समय `:latest` टैग का उपयोग नहीं करना चाहिए क्योंकि यह इमेज के कौनसे संस्करण का उपयोग हो रहा है उसे ट्रैक करना अधिक मुश्किल होता है और यथार्थ रूप से वापस रोलबैक करना अधिक कठिन होता है।

इसके बजाय, आप `v1.42.0` जैसे कोई अर्थपूर्ण टैग निर्दिष्ट करें।
{{< /note >}}

एक कंटेनर इमेज के संस्करण को हमेशा समान रखने के लिए, आप इमेज के डाइजेस्ट को निर्दिष्ट कर सकते हैं;
<`image-name`>:<tag> को `<image-name>@<digest>` से बदलें
(उदाहरण के लिए, `image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2`).

जब आप इमेज टैग का उपयोग करते हैं, तो यदि इमेज रजिस्ट्री कोड में उस टैग को बदल देता है तो आप पुराने और नए कोड दोनों के साथ पोड चलाने के मिश्रण से गुजर सकते हैं। एक इमेज डाइजेस्ट एक विशिष्ट संस्करण को अकेले अंकित करता है, इसलिए कुबेरनेट्स उस इमेज नाम और डाइजेस्ट को निर्दिष्ट करते समय हर बार उसी कोड को चलाता है जिसे स्पष्ट किया गया है। डाइजेस्ट द्वारा इमेज का निर्दिष्टीकरण करने से आप उस कोड को ठीक करते हैं जिसे आप चलाते हैं ताकि रजिस्ट्री में कोई भी टैग परिवर्तन उस मिश्रण के लिए नहीं हो सकता जो आपने चलाया है।


पॉड बनाए जाते समय थर्ड-पार्टी [एडमिशन नियंत्रक](/docs/reference/access-authn-authz/admission-controllers/) होते हैं जो पॉड (और पॉड टेम्पलेट) में म्यूटेट करते हैं, ताकि चल रहे workload को tag
के बजाय एक इमेज डाइजेस्ट पर निर्धारित किया जाए। इससे सुनिश्चित होता है कि रजिस्ट्री में कुछ टैग के बदलाव के बाद भी आपका सभी workload उसी कोड पर चल रहा हो।



#### पूर्व निर्धारित मूल्य इमेज पुल पालिसी  {#imagepullpolicy-defaulting}

जब आप (या एक नियंत्रक) नई Pod को API सर्वर पर सबमिट करते हैं, तो आपके क्लस्टर निश्चित स्थितियों को पूरा करते हुए `imagePullPolicy` फ़ील्ड सेट करता है:


- यदि आप कंटेनर इमेज के लिए `:latest` टैग निर्दिष्ट नहीं करते हैं, और आप `imagePullPolicy` फ़ील्ड छोड़ते हैं, तो `imagePullPolicy` स्वचालित रूप से `Always` पर सेट किया जाता है।
- यदि आप कंटेनर इमेज के लिए टैग निर्दिष्ट नहीं करते हैं, और आप `imagePullPolicy` फ़ील्ड छोड़ते हैं, तो `imagePullPolicy` स्वचालित रूप से `Always` पर सेट किया जाता है।
- यदि आप कंटेनर इमेज के लिए टैग निर्दिष्ट करते हैं जो `:latest` नहीं है, और आप `imagePullPolicy` फ़ील्ड छोड़ते हैं, तो `imagePullPolicy` स्वचालित रूप से `IfNotPresent` पर सेट किया जाता है।


{{< note >}}
जब ऑब्जेक्ट पहली बार बनाया जाता है, तब कंटेनर का `imagePullPolicy` का मान सेट होता है, और यदि बाद में उस इमेज की टैग बदल जाती है, तो यह फ़ील्ड अपडेट नहीं होती है।

उदाहरण के लिए, यदि आप एक Deployment बनाते हैं जिसमें इमेज की टैग अपडेट नहीं होती है, और बाद में उस Deployment की इमेज को एक `:latest` टैग के साथ अपडेट करते हैं, तो `imagePullPolicy` फ़ील्ड `Always` पर नहीं बदलेगी। आपको किसी भी ऑब्जेक्ट की इनिशियल क्रिएशन के बाद उसकी पुल पॉलिसी को मैन्युअल रूप से बदलना होगा।
{{< /note >}}


#### ज़रूरी इमेज पुल


यदि आप हमेशा एक फोर्स पुल करना चाहते हैं, तो आप निम्नलिखित में से कुछ कर सकते हैं:

- कंटेनर के `imagePullPolicy` को `Always` पर सेट करें।
- `imagePullPolicy` को छोड़ दें और उपयोग करें `:latest` इमेज के लिए टैग; कुबेरनेट्स
पॉड सबमिट करते समय नीति को `Always` पर सेट कर देगा।
- `imagePullPolicy` और उपयोग करें इमेज के लिए टैग को छोड़ दें;
  कुबेरनेट्स पॉड सबमिट करते समय नीति को `Always` पर सेट कर देगा।
- [AlwaysPullImages](/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) एडमिशन नियंत्रक को सक्षम करें।


### इमेजपुलबैकॉफ (ImagePullBackOff)

जब कोई कुबलेट किसी Pod के लिए container runtime का उपयोग करते हुए containers बनाना शुरू करता है, तो यह संभव है कि `ImagePullBackOff` के कारण container [Waiting](/docs/concepts/workloads/pods/pod-lifecycle/#container-state-waiting) स्थिति में हो।


स्थिति `ImagePullBackOff` यह दर्शाती है कि कुबरनेटीज एक कंटेनर इमेज को पुल करने में असमर्थ हो गया है (गलत इमेज नाम या `imagePullSecret` के बिना निजी रजिस्ट्री से पुल करने के जैसे कारणों के कारण). `BackOff` भाग इस बात को दर्शाता है कि कुबरनेटीज इमेज पुल करने का प्रयास करता रहेगा, जिसमें बैक-ऑफ देरी को बढ़ाया जाएगा।

कुबरनेटीज प्रत्येक प्रयास के बीच देरी को बढ़ाते हुए उस सीमा तक पहुंचता है, जो कंपाइल किए गए लिमिट, अर्थात 300 सेकंड (5 मिनट) है।

## इमेज इंडेक्स के साथ मल्टी-आर्किटेक्चर इमेजेज (Multi-architecture images with image indexes)

बाइनरी इमेजयों की प्रदान के साथ-साथ, एक कंटेनर रजिस्ट्री एक [container image index](https://github.com/opencontainers/image-spec/blob/master/image-index.md) भी प्रदान कर सकती है। इमेज इंडेक्स एक कंटेनर
के विभिन्न संरचना-विशिष्ट संस्करणों के लिए अनुशंसित [image manifests](https://github.com/opencontainers/image-spec/blob/master/manifest.md) को निर्देशित कर सकता है। यह विचार है कि आप एक इमेज के लिए
एक नाम रख सकते हैं (उदाहरण के लिए: `pause`, `example/mycontainer`, `kube-apiserver`) और अलग-अलग सिस्टम को वे
उपयोग कर रहे मशीन आर्किटेक्चर के लिए सही बाइनरी इमेज फेच करने की अनुमति दें।

कुबरनेट्स आमतौर पर कंटेनर इमेजयों को एक सुफ़िक्स `-$(ARCH)` के साथ नामकरण करता है। पूर्व संगतता के लिए, कृपया सुफ़िक्स के साथ पुरानी इमेजयां उत्पन्न करें। विचार यह है कि आप
उदाहरण के रूप में `pause` इमेज उत्पन्न कर सकते हैं जिसमें सभी arch(es) के लिए मैनिफ़ेस्ट होता है और `pause-amd64` उत्पन्न कर सकते हैं जो पुराने विन्यास या YAML फ़ाइलों में सुफ़िक्स के साथ नाम रखने वाली पुरानी इमेज संगत होती हैं।


## एक निजी रजिस्ट्री का उपयोग करना

निजी रजिस्ट्री को पढ़ने के लिए ताकत की आवश्यकता हो सकती है।
क्रेडेंशियल कई तरीकों से प्रदान किए जा सकते हैं:

- नोड को निजी रजिस्ट्री से प्रमाणित करने के लिए नोड को कॉन्फ़िगर करना 
  - सभी पॉड को कॉन्फ़िगर किए गए निजी रजिस्ट्रियों को पढ़ सकते हैं
  - क्लस्टर प्रशासक द्वारा नोड कॉन्फ़िगर की आवश्यकता होती है
- निजी रजिस्ट्री के लिए क्रेडेंशियल डायनामिक रूप से प्राप्त करने के लिए कुबलेट क्रेडेंशियल प्रदाता
  - कुबलेट क्रेडेंशियल प्रदाता exec प्लगइन का उपयोग करने के लिए कॉन्फ़िगर किया जा सकता है निजी रजिस्ट्री के लिए।
- पूर्व-खींची गई इमेजयां
  - सभी पॉड किसी भी नोड पर कैश की गई कोई भी इमेज का उपयोग कर सकते हैं
  - सेटअप के लिए सभी नोडों में रूट एक्सेस की आवश्यकता होती है
- पॉड पर ImagePullSecrets निर्दिष्ट करना
  - केवल वे पॉड जिनके पास अपने कुंजी हैं वह निजी रजिस्ट्री तक पहुंच प्राप्त कर सकते हैं।
- वेंडर-विशिष्ट या स्थानीय विस्तार 
  - यदि आप एक कस्टम नोड कॉन्फ़िगरेशन का उपयोग कर रहे हैं, तो आप (या अपने क्लाउड प्रोवाइडर) अपनी तरह से नोड को प्रमाणित करने के लिए अपनी युक्ति को लागू कर सकते हैं।


इन विकल्पों का नीचे और अधिक विस्तार से व्याख्या दी गई है।

### निजी रजिस्ट्री में प्रमाणित करने के लिए नोड कॉन्फ़िगर करना


container रनटाइम और रजिस्ट्री के सेट करने के लिए निश्चित निर्देशों के लिए आपको अपने सॉल्यूशन के दस्तावेज़ का संदर्भ देना चाहिए। सटीक जानकारी के लिए अपने सॉल्यूशन के दस्तावेज़ का संदर्भ दें।

निजी कंटेनर इमेज रजिस्ट्री कॉन्फ़िगर करने के उदाहरण के लिए, [प्राइवेट रजिस्ट्री से इमेज खींचें](/docs/tasks/configure-pod-container/pull-image-private-registry) टास्क देखें। उस उदाहरण में Docker Hub में एक निजी रजिस्ट्री का उपयोग किया गया है।


### प्रमाणित इमेज खींचने के लिए कुबलेट प्रमाणित प्रदाता {#कुबलेट-credential-provider}

{{< note >}}
यह दृष्टिकोण विशेष रूप से उपयुक्त है जब कुबलेट को रजिस्ट्री प्रमाणपत्र डायनामिक रूप से फ़ेच करने की आवश्यकता होती है।
सबसे अधिक प्रयोग किया जाने वाला रजिस्ट्री क्लाउड प्रोवाइडर द्वारा प्रदान किए जाने वाले रजिस्ट्री के लिए जहां ऑथ टोकन छोटी अवधि वाले होते हैं।
{{< /note >}}

आप कुबलेट को कॉन्टेनर इमेज के लिए रजिस्ट्री प्रमाणपत्र डायनामिक रूप से फ़ेच करने के लिए प्लगइन बाइनरी को आवाहित करने के लिए कॉन्फ़िगर कर सकते हैं।
यह निजी रजिस्ट्री के लिए प्रमाणपत्र फ़ेच करने के लिए सबसे मजबूत और विविध तरीके में से एक है, लेकिन कुबलेट-स्तरीय विन्यास को सक्षम करने के लिए भी आवश्यक होता है।

अधिक जानकारी के लिए [कुबलेट इमेज प्रमाणपत्र प्रदाता कॉन्फ़िगर करें](/docs/tasks/administer-cluster/कुबलेट-credential-provider/) देखें।

### config.json की व्याख्या (Interpretation of config.json) {#config-json}

`config.json` की व्याख्या मूल Docker अंमलवार्ता और कुबेरनेट्स व्याख्या के बीच भिन्न होती है। Docker में, `auths` कुंजियाँ केवल रूट URL निर्दिष्ट कर सकती हैं,
जबकि कुबेरनेट्स विस्तृत URL के साथ साथ उपसर्ग-मेलित पथ भी अनुमति देता है। इसका अर्थ है कि एक `config.json` जैसा कि यह मान्य है:


```json
{
    "auths": {
        "*my-registry.io/images": {
            "auth": "…"
        }
    }
}
```

निम्नलिखित वाक्यांश का उपयोग करके रूट URL (`*my-registry.io`) का मेल लिया जाता है:

```
pattern:
    { term }

term:
    '*'         matches any sequence of non-Separator characters
    '?'         matches any single non-Separator character
    '[' [ '^' ] { character-range } ']'
                character class (must be non-empty)
    c           matches character c (c != '*', '?', '\\', '[')
    '\\' c      matches character c

character-range:
    c           matches character c (c != '\\', '-', ']')
    '\\' c      matches character c
    lo '-' hi   matches character c for lo <= c <= hi
```


इमेज पुल ऑपरेशन अब हर मान्य पैटर्न के लिए CRI कंटेनर रनटाइम को क्रेडेंशियल पास कर देंगे। उदाहरण के लिए, निम्नलिखित कंटेनर इमेज नाम सफलतापूर्वक मेल खाएंगे:

- `my-registry.io/images`
- `my-registry.io/images/my-image`
- `my-registry.io/images/another-image`
- `sub.my-registry.io/images/my-image`
- `a.sub.my-registry.io/images/my-image`


कुबलेट हर पाए गए क्रेडेंशियल के लिए इमेज पुल को क्रमशः करता है। इसका अर्थ है कि `config.json` में एकाधिक प्रविष्टियां भी संभव हैं:

```json
{
    "auths": {
        "my-registry.io/images": {
            "auth": "…"
        },
        "my-registry.io/images/subpath": {
            "auth": "…"
        }
    }
}
```


यदि अब एक कंटेनर एक इमेज `my-registry.io/images/subpath/my-image` को खींचने के लिए निर्दिष्ट करता है, तो कुबलेट दोनों प्रमाणीकरण स्रोतों से उन्हें डाउनलोड करने की कोशिश करेगा यदि उनमें से एक विफल हो जाए।

### पूर्व-खींची गई इमेजयाँ (Pre-pulled images)


{{< note >}}
यदि आप नोड कॉन्फ़िगरेशन को नियंत्रित कर सकते हैं तो यह दृष्टिकोण उपयुक्त है। यदि आपका क्लाउड प्रदाता नोडों को प्रबंधित करता है और उन्हें स्वचालित रूप से बदलता है तो यह स्पष्ट नहीं है कि यह निष्पक्ष काम करेगा।
{{< /note >}}


डिफ़ॉल्ट रूप से, कुबलेट निर्दिष्ट रजिस्ट्री से प्रत्येक इमेज खींचने की कोशिश करता है।
हालांकि, यदि कंटेनर की `imagePullPolicy` संपत्ति को `IfNotPresent` या `Never` में सेट किया गया है,
तो एक स्थानीय इमेज का उपयोग किया जाता है (प्राथमिक रूप से या अकेले रूप से।)

यदि आप रजिस्ट्री प्रमाणीकरण के बदले पूर्व-खींची गई इमेजयों पर भरोसा करना चाहते हैं,
तो आपको सुनिश्चित करना होगा कि क्लस्टर में सभी नोड एक ही पूर्व-खींची गई इमेजयों के साथ हों।

यह स्पीड के लिए निशुल्क रूप से कुछ इमेजयों को पूर्व-लोड करने या एक निजी रजिस्ट्री को प्रमाणित करने के विकल्प के रूप में उपयोग किया जा सकता है।

सभी पॉडों को किसी भी पूर्व-खींची गई इमेजयों के लिए रीड एक्सेस होगा।


### कंटेनर इमेज रजिस्ट्री कुंजियों को पॉड पर निर्दिष्ट करना


{{< note >}}
यह निजी रजिस्ट्री से आधारित इमेजेस पर आधारित कंटेनर चलाने के लिए सिफारिश की जाती है।
{{< /note >}}

कुबरनेटीज़ पॉड पर कंटेनर इमेज रजिस्ट्री कुंजियों को निर्दिष्ट करने का समर्थन करता है।
`imagePullSecrets` पॉड के समान नेमस्पेस में होना चाहिए। उल्लिखित गुप्ततासूत्रों को
क्रमशः टाइप `kubernetes.io/dockercfg` या `kubernetes.io/dockerconfigjson` होना चाहिए।


#### डॉकर कॉन्फ़िग के साथ एक सीक्रेट बनाना


डॉकर कॉन्फ़िग के साथ एक सीक्रेट बनाना

आपको रजिस्ट्री में प्रमाणित होने के लिए उपयोगकर्ता नाम, रजिस्ट्री पासवर्ड और क्लाइंट ईमेल पता,
उसके होस्टनेम की भी जानकारी होनी चाहिए। निम्नलिखित आदेश को चलाएं, उचित अपरकेस मूल्यों का उपयोग करते हुए:

```shell
kubectl create secret docker-registry <name> \
  --docker-server=DOCKER_REGISTRY_SERVER \
  --docker-username=DOCKER_USER \
  --docker-password=DOCKER_PASSWORD \
  --docker-email=DOCKER_EMAIL
```


यदि आपके पास पहले से ही एक Docker प्रमाणीकरण फ़ाइल है तो उपरोक्त आदेश का उपयोग करने के बजाय, आप इसे कुबेरनेट्स
{{<glossary_tooltip text="Secrets" term_id="secret">}} के रूप में आयात कर सकते हैं। [मौजूदा Docker प्रमाणीकरण के आधार पर एक Secret बनाएं](/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials) इसका विवरण बताता है।

यह विशेष रूप से उपयोगी होता है यदि आप एक से अधिक निजी कंटेनर रजिस्ट्री का उपयोग कर रहे हैं, क्योंकि `kubectl create secret docker-registry` एक Secret बनाता है जो केवल एक निजी रजिस्ट्री के साथ काम करता है।

{{< note >}}
Pods केवल अपनी खुद की नेमस्पेस में इमेज पुल सीक्रेट को संदर्भित कर सकते हैं, इसलिए इस प्रक्रिया को एक बार प्रति नेमस्पेस करने की आवश्यकता होती है।
{{< /note >}}



#### एक Pod पर imagePullSecrets को संदर्भित करना


एक Pod पर imagePullSecrets को संदर्भित करना

अब, आप `imagePullSecrets` कोड सेक्शन को Pod definition में जोड़कर उस सीक्रेट का संदर्भ जोड़ सकते हैं। `imagePullSecrets` एरे में हर आइटम केवल एक नेमस्पेस में एक सीक्रेट को संदर्भित कर सकता है।

उदाहरण के लिए:


```shell
cat <<EOF > pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: foo
  namespace: awesomeapps
spec:
  containers:
    - name: foo
      image: janedoe/awesomeapp:v1
  imagePullSecrets:
    - name: myregistrykey
EOF

cat <<EOF >> ./kustomization.yaml
resources:
- pod.yaml
EOF
```


यह हर Pod के लिए किया जाना चाहिए जो निजी रजिस्ट्री का उपयोग कर रहा है।

हालांकि, इस फ़ील्ड की सेटिंग को इमेजपुल सीक्रेट्स को सेट करके [ServiceAccount](/docs/tasks/configure-pod-container/configure-service-account/) रिसोर्स में सेट करके स्वचालित बनाया जा सकता है।

विस्तृत निर्देशों के लिए [Service Account में ImagePullSecrets जोड़ें](/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account) की जांच करें।

आप इसे प्रति-नोड `.docker/config.json` के साथ उपयोग कर सकते हैं। प्रमाणिकरण मिलाया जाएगा।


## उपयोग मामले

निजी रजिस्ट्री को कॉन्फ़िगर करने के लिए कई समाधान हैं। यहां कुछ सामान्य उपयोग मामले और सुझाए गए समाधान हैं।


1. केवल गैर-प्राप्राइटरी (जैसे ओपन सोर्स) इमेजेस से चल रहा क्लस्टर। इमेजेस को छुपाने की आवश्यकता नहीं है। 
   - पब्लिक रजिस्ट्री से पब्लिक इमेज का उपयोग करें
     - कोई कॉन्फ़िगरेशन आवश्यक नहीं है।
     - कुछ क्लाउड प्रदाताओं अपने आप पब्लिक इमेज कैश या मिरर कर देते हैं, जो उपलब्धता को बढ़ाता है और इमेज खींचने के लिए समय को कम करता है।
1. कंपनी के बाहर वालों को छुपाया जाना चाहिए, लेकिन सभी क्लस्टर उपयोगकर्ताओं के लिए दृश्यमान होना चाहिए।
   - एक होस्ट किए गए निजी रजिस्ट्री का उपयोग करें
   - निजी रजिस्ट्री तक पहुँच करने वाले नोडों पर मैन्युअल कॉन्फ़िगरेशन की आवश्यकता हो सकती है
   - या फिर, अपने फ़ायरवॉल के पीछे एक आंतरिक निजी रजिस्ट्री चलाएं जिसके खोलने की अनुमति है।
   - कुबरनेटीस कॉन्फ़िगरेशन की कोई आवश्यकता नहीं है।
   - एक होस्ट किए गए कंटेनर इमेज रजिस्ट्री सेवा का उपयोग करें जो इमेज उपयोग की निगरानी करती है
   - इससे मैन्युअल नोड कॉन्फ़िगरेशन से क्लस्टर ऑटोस्केलिंग बेहतर काम करेगा।
   - या फिर, जहाँ नोड कॉन्फ़िगरेशन बदलना असुविधाजनक हो, `imagePullSecrets` का उपयोग करें।
1. एक cluster जिसमें proprietary images होती हैं, उनमें से कुछ को अधिक सख्त एक्सेस कंट्रोल की आवश्यकता होती है।
   - [AlwaysPullImages admission controller](/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) सक्रिय होने का सुनिश्चय करें। इससे पहले, सभी Pods के पास संभवतः सभी इमेजयों तक पहुंच होती है।
   - संवेदनशील डेटा को इमेज में पैकेज करने की बजाय, इसे "Secret" resource में ले जाएँ।
1. एक मल्टी-टेनेंट क्लस्टर जहां हर टेनेंट को अपनी निजी रजिस्ट्री की आवश्यकता है।
   - सुनिश्चित करें कि [AlwaysPullImages admission controller](/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) सक्रिय है। अन्यथा, सभी Pods या सभी tenants को संभवतः सभी इमेजयों तक पहुँच होगी।
   - एक ऑथराइज़ेशन के साथ एक निजी रजिस्ट्री चलाएं।
   - हर टेनेंट के लिए रजिस्ट्री credential उत्पन्न करें, सीक्रेट में डालें, और हर टेनेंट नेमस्पेस में सीक्रेट को भरें।
   - टेनेंट नेमस्पेस के imagePullSecrets में उस सीक्रेट को जोड़ें।


यदि आपको कई रजिस्ट्री का उपयोग करने की आवश्यकता है, तो आप प्रत्येक रजिस्ट्री के लिए एक सीक्रेट बना सकते हैं।


{{% heading "whatsnext" %}}
* [OCI Image Manifest Specification](https://github.com/opencontainers/image-spec/blob/master/manifest.md) को पढ़ें।
* [container image garbage collection](/docs/concepts/architecture/garbage-collection/#container-image-garbage-collection) के बारे में जानें।
* [pulling an Image from a Private Registry](/docs/tasks/configure-pod-container/pull-image-private-registry) के बारे में अधिक जानें।