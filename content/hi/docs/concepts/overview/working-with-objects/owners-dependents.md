---
title: मालिक और आश्रित
content_type: concept
weight: 90
---

<!-- overview -->

कुबेरनेट्स में कुछ {{< glossary_tooltip text="objects" term_id="object" >}} 
अन्य वस्तुओं के *owners* हैं , उदाहरण के लिए,

{{<glossary_tooltip text="ReplicaSet" term_id="replica-set">}} पॉड्स के 
 एक सेट का owner है । ये स्वामित्व वाली वस्तुएँ उनके owner के *dependents* हैं।


स्वामित्व से भिन्न है [लेबल और चयनकर्ता](/docs/concepts/overview/working-with-objects/labels/)
वह तंत्र जिसका उपयोग कुछ संसाधन भी करते हैं। उदाहरण के लिए, एक ऐसी सेवा पर विचार करें
बनाता है `EndpointSlice` वस्तुएं. सेवा उपयोग करती है {{<glossary_tooltip text="labels" term_id="label">}} नियंत्रण विमान को अनुमति देने के लिए
निर्धारित करें कि कौन सा EndpointSlice उस सेवा के लिए वस्तुओं का उपयोग करता है। इसके अलावा
प्रत्येक लेबल पर `EndpointSlice` जिसे किसी सेवा की ओर से प्रबंधित किया जाता है
एक मालिक संदर्भ। स्वामी संदर्भ कुबेरनेट्स के विभिन्न हिस्सों से बचने में मदद करते हैं
उन वस्तुओं में हस्तक्षेप करना जिन पर उनका नियंत्रण नहीं है।

## वस्तु विशिष्टताओं में स्वामी संदर्भ

आश्रित वस्तुओं में एक है `metadata.ownerReferences` होता है जो खुद उनका संदर्भ देता है
एक वैध स्वामी संदर्भ में ऑब्जेक्ट का नाम और आश्रित ऑब्जेक्ट के समान नामस्थान के भीतर 
एक {{<glossary_tooltip text="UID" term_id="uid">}} शामिल होता है।
कुबेरनेट्स उन वस्तुओं के लिए इस फ़ील्ड का मान स्वचालित रूप से निर्धारित करता है जो अन्य वस्तुओं पर निर्भर हैं
रेप्लिकासेट्स, डेमॉनसेट्स, परिनियोजन, नौकरियां और क्रोनजॉब्स, और रेप्लिकेशनकंट्रोलर।	
आप इन संबंधों को मान बदलकर मैन्युअल रूप से भी कॉन्फ़िगर कर सकते हैं
यह क्षेत्र। हालाँकि, आमतौर पर आपको इसकी आवश्यकता नहीं होती है और आप कुबेरनेट्स को इसकी अनुमति दे सकते हैं
रिश्तों को स्वचालित रूप से प्रबंधित करें।

Dependent वस्तुओं में एक ownerReferences.blockOwnerDeletion फ़ील्ड भी होता है जो
एक बूलियन मान लेता है और नियंत्रित करता है कि क्या विशिष्ट आश्रित कचरा रोक सकते हैं
उनके स्वामी ऑब्जेक्ट को हटाने से संग्रह। कुबेरनेट्स इसे स्वचालित रूप से सेट करता है
फ़ील्ड को `true` यदि एक {{<glossary_tooltip text="controller" term_id="controller">}} 
(उदाहरण के लिए, परिनियोजन नियंत्रक) का मान निर्धारित करता है
`metadata.ownerReferences` मैदान। आप का मान भी निर्धारित कर सकते हैं
blockOwnerDeletion फ़ील्ड का मान मैन्युअल रूप से भी सेट कर सकते हैं कि कौन से आश्रित कचरा संग्रहण को रोकते हैं।

कुबेरनेट्स प्रवेश नियंत्रक इस फ़ील्ड को बदलने के लिए उपयोगकर्ता की पहुंच को नियंत्रित करता है
स्वामी की डिलीट अनुमतियों के आधार पर निर्भर संसाधन। यह नियंत्रण
अनधिकृत उपयोगकर्ताओं को स्वामी ऑब्जेक्ट को हटाने में देरी करने से रोकता है।

{{< note >}}
डिज़ाइन द्वारा क्रॉस-नेमस्पेस स्वामी संदर्भों की अनुमति नहीं है।
नेमस्पेस्ड आश्रित क्लस्टर-स्कोप्ड या नेमस्पेस्ड मालिकों को निर्दिष्ट कर सकते हैं।
एक नेमस्पेस्ड स्वामी आश्रित के समान नेमस्पेस में मौजूद होना चाहिए।
यदि ऐसा नहीं होता है, तो स्वामी संदर्भ को अनुपस्थित और आश्रित माना जाता है
एक बार सभी स्वामियों की अनुपस्थिति सत्यापित हो जाने पर इसे हटा दिया जाएगा।

क्लस्टर-स्कोप्ड आश्रित केवल क्लस्टर-स्कोप्ड मालिकों को निर्दिष्ट कर सकते हैं।
V1.20+ में, यदि कोई क्लस्टर-स्कोप आश्रित स्वामी के रूप में एक नेमस्पेस प्रकार निर्दिष्ट करता है,
इसे एक समाधान न करने योग्य स्वामी संदर्भ के रूप में माना जाता है, और यह कचरा एकत्र करने में सक्षम नहीं है।
v1.20+ में, यदि कचरा संग्रहकर्ता किसी अमान्य का पता लगाता है cross-namespace `ownerReference`,
या cluster-scoped dependent एक साथ ownerReference एक नेमस्पेस प्रकार का संदर्भ, एक चेतावनी घटना
के एक कारण के साथ `OwnerRefInvalidNamespace` और एक `involvedObject` अमान्य आश्रित की सूचना दी गई है।
आप चलाकर उस प्रकार के ईवेंट की जांच कर सकते हैं
`kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace`.
{{< /note >}}

## स्वामित्व और अंतिमीकरणकर्ता

जब आप कुबेरनेट्स को किसी संसाधन को हटाने के लिए कहते हैं, तो एपीआई सर्वर इसकी अनुमति देता है
किसी भी प्रक्रिया के लिए प्रबंध नियंत्रक [finalization rules](/docs/concepts/overview/working-with-objects/finalizers/)
संसाधन के लिए. {{<glossary_tooltip text="Finalizers" term_id="finalizer">}}
उन संसाधनों के आकस्मिक विलोपन को रोकें जिनकी आपके क्लस्टर को अभी भी कार्य करने की आवश्यकता हो सकती है
सही ढंग से. उदाहरण के लिए, यदि आप हटाने का प्रयास करते हैं [PersistentVolume](/docs/concepts/storage/persistent-volumes/) वह अभी भी है
पॉड द्वारा उपयोग में, विलोपन तुरंत नहीं होता क्योंकि
`PersistentVolume` है `kubernetes.io/pv-protection`इस पर अंतिम रूप देने वाला।
इसके बजाय, [volume](/docs/concepts/storage/volumes/) में रहता है `Terminating` कुबेरनेट्स साफ़ होने तक स्थिति
अंतिमीकरण, जो केवल इसके बाद होता है `PersistentVolume` ज्यादा देर तक नहीं है
एक पॉड से बंधा हुआ।
जब आप इनमें से किसी एक का उपयोग करते हैं तो कुबेरनेट्स किसी स्वामी संसाधन में फ़ाइनलाइज़र भी जोड़ता है
[foreground or orphan cascading deletion](/docs/concepts/architecture/garbage-collection/#cascading-deletion).
अग्रभूमि विलोपन में, यह जोड़ता है `foreground` अंतिम रूप देने वाला ताकि
नियंत्रक को उस पर निर्भर संसाधनों को भी हटाना होगा
`ownerReferences.blockOwnerDeletion=true` इससे पहले कि वह स्वामी को हटा दे. अगर आप
एक अनाथ विलोपन नीति निर्दिष्ट करें, Kubernetes जोड़ता है `orphan` अंतिम रूप देनेवाला तो
नियंत्रक स्वामी के वस्तु को हटाने के बाद निर्भर संसाधनों को अनदेखा कर देता है |

## {{% heading "whatsnext" %}}

* बारे में और सीखो [कुबेरनेट्स को अंतिम रूप देने वाले](/docs/concepts/overview/working-with-objects/finalizers/).
* के बारे में जानना [कचरा संग्रहण](/docs/concepts/architecture/garbage-collection).
* इसके लिए एपीआई संदर्भ पढ़ें [ऑब्जेक्ट मेटाडेटा](/docs/reference/kubernetes-api/common-definitions/object-meta/#System).
