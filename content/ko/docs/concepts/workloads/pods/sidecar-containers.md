---
title: 사이드카 컨테이너
content_type: concept
weight: 50
---

<!-- overview -->
{{< feature-state for_k8s_version="v1.29" state="beta" >}}

사이드카 컨테이너는 주 애플리케이션 컨테이너와 함께 동일한 {{< glossary_tooltip text="파드" term_id="pod" >}} 내에서 실행되는 보조 컨테이너이다.
이러한 컨테이너들은 로깅, 모니터링, 보안, 또는 데이터 동기화와 같은
추가적인 서비스나 기능을 제공함으로써
주 애플리케이션 컨테이너의 기능을 향상시키거나 확장시키는 데 사용된다.
이는 주 애플리케이션 코드를 직접 변경하지 않고도 가능하다.

<!-- body -->

## 사이드카 컨테이너 활성화

쿠버네티스 1.29부터 기본적으로 활성화된
`SidecarContainers`라는
[기능 게이트](/ko/docs/reference/command-line-tools-reference/feature-gates/)를 통해 파드의
`initContainers` 필드에 나열된 컨테이너에 대한 `restartPolicy`를 지정할 수 있다. 이러한 재시작 가능한 _사이드카_ 컨테이너는
다른 [초기화 컨테이너](/ko/docs/concepts/workloads/pods/init-containers/) 및 주 애플리케이션 컨테이너와 독립적이다.
이들은 주 애플리케이션 컨테이너 및
기타 초기화 컨테이너에 영향을 주지 않고 시작, 중지 또는 재시작될 수 있다.

## 사이드카 컨테이너와 파드 라이프사이클

초기화 컨테이너가 `restartPolicy`를 `Always`로 설정하여 생성되면
파드의 전체 수명 동안 실행되고 유지된다.
이는 주 애플리케이션 컨테이너와 분리된 지원 서비스를 실행하는 데 유용하다.

해당 초기화 컨테이너에 `readinessProbe`가 지정된 경우,
그 결과는 파드의 `ready` 상태를 결정하는 데 사용된다.

이러한 컨테이너들이 초기화 컨테이너로 정의되기 때문에, 다른 초기화 컨테이너와 동일한
순서 및 순차적 보장의 이점을 누릴 수 있으므로 다른 초기화 컨테이너와
함께 사용하여 복잡한 파드 초기화 흐름을 만들 수 있다.

일반적인 초기화 컨테이너와 비교할 때, `initContainers` 내에 정의된 사이드카는
시작된 후에도 계속 실행된다. 이는
`.spec.initContainers`의 파드 내에 둘 이상의 항목이 있을 때 중요하다. 사이드카 스타일의 초기화 컨테이너가 실행 중일 때 (kubelet이
해당 초기화 컨테이너의 `started `상태를 true로 설정함), kubelet은 순차적인 `.spec.initContainers` 목록에서
다음 초기화 컨테이너를 시작한다.
이 상태는 컨테이너 내에 프로세스가 실행 중이고 정의된 시작 프로브가 없는 경우 true가 되고,
정의된 시작 프로브가 있는 경우 `startupProbe`의 결과값을 따른다.

다음은 두 개의 컨테이너 중 한 컨테이너가 사이드카인 디플로이먼트(Deployment)의 예시이다.

{{% code_sample language="yaml" file="application/deployment-sidecar.yaml" %}}

이 기능은 사이드카 컨테이너가 주
컨테이너가 종료된 후에도 잡을 완료하지 못하게 하지 않으므로
사이드카가 있는 잡들을 실행하는 데에도 유용하다.

다음은 두 개의 컨테이너 중 한 컨테이너가 사이드카인 잡의 예시이다.

{{% code_sample language="yaml" file="application/job/job-sidecar.yaml" %}}

## 일반 컨테이너와의 차이점

사이드카 컨테이너는 동일한 파드에서 일반 컨테이너와 함께 실행된다.
그러나, 그들은 주 애플리케이션 로직을 실행하지 않고,
주 애플리케이션에 지원 기능을 제공한다.

사이드카 컨테이너는 독립적인 라이프사이클을 가진다. 그들은 일반 컨테이너와 독립적으로 시작, 중지 및
재시작될 수 있다. 이는 주 애플리케이션에 영향을 주지 않고 사이드카 컨테이너를 업데이트,
확장 또는 유지 관리할 수 있음을 의미한다.

사이드카 컨테이너는 주 컨테이너와 동일한 네트워크 및 저장소 네임스페이스를 공유한다.
이로 인해 그들이 밀접하게 상호 작용하고 리소스를 공유할 수 있다.

## 초기화 컨테이너와의 차이점

사이드카 컨테이너는 주 컨테이너와 함께 작동하여 기능을 확장하고
추가 서비스를 제공한다.

사이드카 컨테이너는 주 애플리케이션 컨테이너와 동시에 실행된다. 그들은 파드의 라이프사이클
내내 활성화되며,
주 컨테이너와 독립적으로 시작 및 중지될 수 있다. [초기화 컨테이너](/ko/docs/concepts/workloads/pods/init-containers/)와 달리,
사이드카 컨테이너는 라이프사이클을 제어하기 위해 [프로브](/ko/docs/concepts/workloads/pods/pod-lifecycle/#프로브-종류)를 지원한다.

이러한 컨테이너는 주 애플리케이션 컨테이너와 직접 상호 작용할 수 있으며,
동일한 네트워크 네임스페이스, 파일 시스템 및 환경 변수를 공유한다. 그들은 주 애플리케이션에
추가 기능을 제공하기 위해 긴밀하게 협력한다.

## 컨테이너 내 리소스 공유

{{< comment >}}
이 섹션은 [초기화 컨테이너](/ko/docs/concepts/workloads/pods/init-containers/)에도 존재한다.
이 섹션을 편집하는 경우, 두 곳 모두 변경한다.
{{< /comment >}}

초기화, 사이드카, 애플리케이션 컨테이너의 실행 순서를 고려할 때,
리소스 사용에 대한 다음과 같은 규칙이 적용된다.

- 모든 초기화 컨테이너에서 정의된 특정 리소스 요청 또는 제한 중 가장 높은 것은 *유효 초기화 요청량/한도*이다.
  리소스 제한이 지정되지 않은 리소스는
  이 *유효 초기화 요청량/한도*를 가장 높은 요청량/한도로 간주한다.
- 파드의 *유효 요청량/한도*는
  [파드 오버헤드](/ko/docs/concepts/scheduling-eviction/pod-overhead/)와 다음 중 더 높은 값의 합이다.
  - 초기화 컨테이너 이외의 모든(앱 및 사이드카 컨테이너)의
    리소스에 대한 요청량/한도의 합계
  - 리소스에 대한 유효 초기화 요청량/한도
- 스케줄링은 유효 요청/한도에 따라 이루어진다. 즉,
  초기화 컨테이너는 파드의 수명 동안 사용되지 않는 초기화를 위한 리소스를
  예약할 수 있다.
- 파드의 *유효 QoS 계층* 에서 QoS (서비스의 품질) 계층은 모든 초기화 컨테이너, 사이드카 컨테이너 및
  앱 컨테이너들의 QoS 계층과 같다.

쿼터 및 한도는 유효 파드 요청량 및 한도에 따라
적용된다.

파드 레벨 제어 그룹 (cgroups)은 유효 파드 요청량 및 한도를 기반으로 한다.
이는 스케줄러와 같다.

## {{% heading "whatsnext" %}}

- [네이티브 사이드카 컨테이너](/blog/2023/08/25/native-sidecar-containers/)에 대한 블로그 게시물을 읽어본다.
- [초기화 컨테이너를 갖는 파드 생성](/ko/docs/tasks/configure-pod-container/configure-pod-initialization/#초기화-컨테이너를-갖는-파드-생성)을 읽어본다.
- [프로브 종류](/ko/docs/concepts/workloads/pods/pod-lifecycle/#프로브-종류): 활성, 준비성, 스타트업 프로브에 관하여 알아본다.
- [파드 오버헤드](/ko/docs/concepts/scheduling-eviction/pod-overhead/)에 대해 알아본다.
