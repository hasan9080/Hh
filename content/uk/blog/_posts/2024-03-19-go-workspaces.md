---
layout: blog
title: 'Використання робочих просторів Go в Kubernetes'
date: 2024-03-19T08:30:00-08:00
slug: go-workspaces-in-kubernetes
---

**Автор:** Тім Хокін [Tim Hockin] (Google)  
**Переклад:** Андрій Головін

[Мова програмування Go](https://go.dev/) відіграла величезну роль в успіху Kubernetes. В міру зростання, розвитку та розширення меж того, що роблять "звичайні" проєкти, команда проєкту Go також розвивала мову та інструменти. У недавніх випусках Go було представлено функцію під назвою "робочі простори" (workspaces), яка спрямовувалася на полегшення управління проєктами, такими як Kubernetes.

Ми щойно завершили значний етап щодо впровадження робочих просторів в Kubernetes, і результати вражають. Наш код став простішим та менш схильним до помилок, і тепер ми вже не перебуваємо на нашому власному технологічному острові.

## GOPATH та модулі Go {#gopath-and-go-modules}

Kubernetes є одним з найбільш помітних проєктів з відкритими сирцями, написаним на Go. Найраніші версії Kubernetes, що сягають 2014 року, були побудовані за допомогою Go 1.3. Сьогодні, через 10 років, Go досягнув версії 1.22 — і дозвольте мені сказати, що за цей час _дуже багато_ чого змінилося.

У 2014 році розробка на Go була повністю заснована на [`GOPATH`](https://go.dev/wiki/GOPATH). Як проєкт Go, Kubernetes дотримувався правил `GOPATH`. Під час підготовки до Kubernetes 1.4 (середина 2016 року) ми представили дерево тек під назвою `staging`. Це дозволило нам прикидатись кількома проєктами, але залишитися в одному git-репозиторії (що мало переваги для швидкості розробки). Це працювало завдяки магії `GOPATH`.

Kubernetes залежить від кількох інструментів генерації коду, які повинні знаходити, зчитувати та записувати пакунки коду Go. Не дивно, що ці інструменти стали залежними від `GOPATH`. Все це працювало досить добре, поки Go не ввів модулі в Go 1.11 (середина 2018 року).

Модулі були відповіддю на проблеми, що накопичились навколо `GOPATH`. Вони надали більше контролю проєктам над тим, як відстежувати та керувати залежностями, і загалом були великим кроком вперед. Kubernetes їх прийняв. Однак модулі мали один серйозний недолік — більшість інструментів Go не могли працювати з кількома модулями одночасно. Це було проблемою для наших інструментів генерації коду та сценаріїв.

На щастя, Go запропонував спосіб тимчасово вимкнути модулі (за допомогою `GO111MODULE`). Ми могли отримати переваги відстеження залежностей модулів, але не гнучкість `GOPATH` для наших інструментів. Ми навіть написали допоміжні інструменти для створення фальшивих дерев `GOPATH` і гралися з символічними посиланнями в нашій теці вендорів (де ми мали знімок наших зовнішніх залежностей), і все працювало.

І протягом останніх 5 років _це_ працювало досить добре. Тобто, це працювало добре, якщо ви не звертали занадто багато уваги на те, що відбувалося. Горе тому, хто мав нещастя працювати з одним з інструментів генерації коду, або системою збірки, або безперервно розширюваним набором унікальних сценаріїв оболонки, які ми використовуємо для склеювання всього разом.

## Проблеми {#the-problems}

Як у будь-якому великому програмному проєкті, ми, розробники Kubernetes, всі навчилися жити з певним рівнем постійних неприємностей. Наш власний `staging` механізм дозволяв нам порушувати правила Go; це було трохи незручно, але коли це працювало (що в більшості випадків так і було), воно працювало досить добре. Коли це зазнавало невдач, помилки були незрозумілими та un-Googleable — ніхто більше не робив тих дурниць, які робили ми. Зазвичай виправленням було перезапускання одного або декількох сценаріїв оболонки `update-*` в нашій, відповідно названій, теці `hack`.

З часом ми віддалилися від "звичайних" проєктів Go все далі та далі. В той самий час Kubernetes ставав все популярнішим. Для багатьох людей Kubernetes був їхнім першим досвідом роботи з Go, і це не завжди був гарний досвід.

Наші ексцентричності також вплинули на людей, які використовували деякий наш код, такий як наша бібліотека клієнтів та інструменти генерації коду (які виявилися корисними в зростаючий екосистемі власних ресурсів). Інструменти працювали тільки в разі зберігання вашого коду в певній структурі тек, сумісній з `GOPATH`, навіть коли `GOPATH` був замінений модулями вже як понад чотири роки.

Цей стан зберігався через збіг трьох чинників:

1. У більшості випадків це лише невеликі неприємності (що перемежовуються короткими моментами значніших проблем).
2. Популярність Kubernetes зростала — всі мали інші, більш важливі справи.
3. Виправлення не було очевидним, і будь-яке рішення вимагало багато зусиль та нудної роботи.

Як супроводжувач Kubernetes та аксакал, я залишив свої відбитки по всій системі збірки, інструментах генерації коду та сценаріях в `hack`. Хоча біль від нашого безладу був _у середньому_ незначним, я був одним із тих, хто відчував його регулярно.

## Створення робочих просторів {#enter-workspaces}

Походу, команда розробників мови Go побачила, що ми (і інші) робимо, і це їм не дуже сподобалось. Вони розробили новий спосіб зшивання кількох модулів у новий концепт _робочого простору_. Після включення до робочого простору, інструменти Go мали достатньо інформації, щоб працювати в будь-якій структурі тек та модулів, без `GOPATH`, символічних посилань чи інших брудних трюків.

Коли я вперше побачив цю пропозицію, я знав, що це вихід (з того стану в якому ми перебували). Це був шлях, щоб вибратись з заторів. Якщо робочі простори є технічним рішенням, то я зроблю все можливе, щоб це сталося.

## Робота {#the-work}

Створення робочих просторів було підступно простим. Я дуже швидко зробив кодову базу, яку можна було компілювати та запускати тести з використанням робочих просторів. Я розпочав очищення репозиторію від всього повʼязаного з `GOPATH`. Ось коли я натрапив на перешкоду — інструменти генерації коду.

У нас було приблизно десяток інструментів, що складалися з кількох тисяч рядків коду. Всі вони були побудовані за допомогою внутрішньої структури, яка називалася [gengo](https://github.com/kubernetes/gengo), яка базувалася на власних бібліотеках аналізу коду Go. Були дві основні проблеми:

1. Ці бібліотеки аналізу не розуміли модулі або робочі простори.
2. `GOPATH` дозволяв нам претендувати на те, що _шляхи пакунків_ Go та теки на диску взаємозамінні у звичайних випадках. Але це не так.

Перехід до використання бібліотеки, яка розуміє [модулі та робочі простори](https://pkg.go.dev/golang.org/x/tools/go/packages), був першим кроком. Потім мені довелося внести довгий ряд змін у кожен з інструментів генерації коду. Критично важливо було знайти спосіб зробити це таким, щоб інші також могли це рецензувати! Я шукав рецензентів, які могли охопити весь діапазон змін та рецензентів, які могли б глибоко зануритись в конкретні теми, такі як gengo та семантика модуля Go. Подивившись на історію тих місць, яких я доторкався, я попросив Joe Betz та Alex Zielenski (SIG API Machinery) докладно дослідити gengo та генерацію коду, Jordan Liggitt (SIG Architecture) розглянути модулі Go та вендоринг та оболонкові сценарії `hack`, а також Antonio Ojea (у ролі представника SIG Testing) переконатися, що весь цей процес має сенс. Ми домовилися, що серія невеликих комітів буде найлегшою для перегляду, навіть якщо кодова база насправді не працювала в кожному коміті.

На жаль, це були не просто механічні зміни. Мені довелося досліджувати кожен інструмент, щоб зрозуміти, де вони обробляли дискові шляхи, а де обробляли імена пакунків, і де ці два аспекти перепліталися. Я використовував [delve debugger](https://github.com/go-delve/delve), і я навіть не можу підібрати відповідних слів подяки.

Одним невдалим наслідком цієї роботи було те, що мені довелося порушити сумісність. Бібліотека gengo просто не мала достатньо інформації для обробки пакунків поза GOPATH. Після обговорення з супроводжувачами gengo та Kubernetes, ми погодилися створити [gengo/v2](https://github.com/kubernetes/gengo/tree/master/v2). Я також використав цей шанс, щоб покращити деякі API та інструменти gengo, а також CLI, щоб вони були більш зрозумілими та не плутали пакунки та теки. Наприклад, ви не можете просто обʼєднати імена тек в рядок та припустити, що результат є дійсною назвою пакунка.

Коли я перевів інструменти генерації коду, я звернув увагу на десятки сценаріїв у теці `hack`. По одному мені довелося запускати їх, відстежувати та виправляти помилки. Деяким з них потрібні були незначні зміни, а деякі потребували повного переписування.

Попутно ми зіткнулись з деякими випадками, які Go не підтримував, як от вендоринг робочих просторів. Kubernetes покладається на вендоринг, щоб переконатись що наші залежності є завжди доступними, навіть якщо їх сирці зниклі з Інтернету (таке траплялось не раз!). Після обговорення з командою Go, та ознайомлення з можливими варіантами розвʼязання цієї проблеми, я вирішив, що найкращим рішенням буде впровадження підтримки вендорингу робочих просторів.

Фінальний пул-реквест містив понад 200 окремих комітів.

## Результати {#results}

Тепер, коли ця робота була обʼєднана з основною кодовою базою, що це означає для користувачів Kubernetes? Практично нічого. Жодні функції не були додані або змінені. Ця робота не стосувалася виправлення помилок (і, сподіваємося, що не було додано жодної нової).

Ця робота була головним чином на користь проєкту Kubernetes, щоб допомогти та спростити життя основним супроводжувачам. Насправді, не буде неправдою сказати, що це було досить корисливо — моє власне життя зараз трохи краще.

Ці зусилля, хоча і несподівано великі, є лише крихітною частиною загальної роботи з обслуговування, яку потрібно було зробити. Як і в будь-якого великого проєкту, у нас є багато "технічних боргів" — інструменти, які робили припущення на певний момент часу і потребують перегляду, внутрішні API, організація яких не має сенсу, код, який не дотримується домовленостей, які не існували в момент його створення, та тести, які можуть бути не настільки ретельними, як це можливо, — щоб згадати лише кілька прикладів. Цю роботу часто називають "брудною" або "грубою", але насправді це лише показник того, що проєкт ріс і еволюціонував. Мені це подобається, але є набагато більше речей, тих, з якими я зможу впоратись будь-коли самостійно, що робить це цікавим способом для людей долучитися. Як говориться у нашому неофіційному девізі: "рубай дрова та носи воду" (роби щоденні справи)[^1].

[^1]: Аналогом ідіоми "chop wood and carry water" може бути вираз "шукати себе в рутинних справах". Обидва виражають ідею про необхідність виконувати повсякденні, прості справи, щоб досягти успіху або дорослішання.

Раніше Kubernetes був прикладом того, як _не_ треба робити розробку масштабних проєктів на Go, але тепер наша кодова база простіша (і в деяких випадках швидша!) та більш послідовна. Речі, які раніше здавалися такими що _повинні_ працювати, але вони не працювали, зараз поводяться так, як очікується.

Наш проєкт тепер трохи більш "звичайний". Хоча не зовсім, але ми намагаємось.

## Подяки {#thanks}

Дякую всім за підтримку.

По-перше, велика подяка команді Go за уважне вислуховування наших проблем, врахування отриманих відгуків і їх вирішення.

Особлива подяка Michael Matloob, з команди Go в Google, який розробив і впровадив робочі простори. Він скеровував мене на кожному кроці та був дуже щедрим на свій час, відповідаючи на всі мої запитання, незалежно від їхньої складності.

Написання коду — лише половина роботи, тому ще раз особлива подяка моїм рецензентам: Jordan Liggitt, Joe Betz, Alexander Zielenski та Antonio Ojea. Ці люди принесли величезний досвід і увагу до деталей, що зробило нашу роботу ефективнішою та безпечнішою.
