---
reviewers:
- erictune
title: Podʼи
content_type: concept
weight: 10
no_list: true
---

<!-- overview -->

_Podʼи_ — найменші обчислювальні одиниці, які ви можете створити та керувати ними в Kubernetes.

_Pod_ (як у випадку з групою китів або гороховим стручком) — це група з одного або кількох {{< glossary_tooltip text="контейнерів" term_id="container" >}}, які мають спільні ресурси зберігання та мережі, а також специфікацію щодо того, як запускати контейнери. Вміст Podʼу завжди розташований та запускається разом, та працює в спільному контексті. Pod моделює "логічний хост" для вашого застосунку: він містить один або кілька контейнерів застосунку, які мають відносно тісний звʼязок один з одним. По за контекстом хмар, застосунки, що виконуються на одному фізичному або віртуальному компʼютері, аналогічні застосункам, що виконуються на одному логічному хості.

Так само як і контейнери застосунків, Podʼи можуть містити [контейнери ініціалізації](/docs/concepts/workloads/pods/init-containers/), які запускаються під час старту Podʼу. Ви також можете впровадити [тимчасові контейнери](/docs/concepts/workloads/pods/ephemeral-containers/) для налагодження, якщо ваш кластер це підтримує.

<!-- body -->

## Що таке Pod? {#what-is-a-pod}

{{< note >}}
Вам потрібно встановити [середовище виконання контейнерів](/docs/setup/production-environment/container-runtimes/) на кожному вузлі кластера, щоб контейнери могли працювати там.
{{< /note >}}

Спільний контекст Podʼу — це набір Linux-просторів імен, cgroups та, можливо, інших аспектів ізоляції — ті самі речі, які ізолюють {{< glossary_tooltip text="контейнер" term_id="container" >}}. В межах контексту Podʼу окремі застосунки можуть мати додаткові підізоляції.

Pod схожий на набір контейнерів із спільними просторами імен та спільними ресурсами файлових систем.

## Використання Podʼів {#using-pods}

Нижче наведено приклад Pod, який складається з контейнера, який запускає образ `nginx:1.14.2`.

{{% code_sample file="pods/simple-pod.yaml" %}}

Для створення Podʼу, показаного вище, виконайте наступну команду:

```shell
kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml
```

Як правило Podʼи не створюються напряму, навіть одиничні Podʼи. Замість цього, створюйте їх за допомогою ресурсів робочих навантажень. Дивіться [Робота з Podʼами](#working-with-pods) для отримання додаткової інформації про те, як Podʼи використовуються разом з ресурсами робочих навантажень.

### Ресурси навантаження для керування Podʼами {#workload-resources-for-managing-pods}

Зазвичай у вас немає потреби у створенні окремих Pod напряму в Kubernetes, навіть одиничних Podʼів. Натомість створюйте їх за допомогою ресурсів робочих навантажень, таких як {{< glossary_tooltip text="Deployment" term_id="deployment" >}} або {{< glossary_tooltip text="Job" term_id="job" >}}. Якщо ваші Podʼи потребують відстеження стану, розгляньте використання ресурсу {{< glossary_tooltip text="StatefulSet" term_id="statefulset" >}}.

Podʼи в кластері Kubernetes використовуються двома основними способами:

* **Podʼи, що керують одним контейнером**. Модель "один контейнер на Pod" є найпоширенішим використанням в Kubernetes. У цьому випадку Pod можна розглядати як обгортку навколо одного контейнера; Kubernetes керує Podʼами, а не контейнерами безпосередньо.
* **Podʼи, що керують кількома контейнерами, які мають працювати разом**. Pod може інкапсулювати застосунок, який складається з кількох розміщених разом контейнерів, які тісно повʼязані та мають спільні ресурси. Такі контейнери утворюють єдиний обʼєкт служби — наприклад, один контейнер може надавати дані, що зберігаються в спільному томі, тоді як інший _sidecar_ контейнер може оновлювати ці файли. Pod огортає ці контейнери, спільні ресурси зберігання та тимчасовий ідентифікатор мережі як єдиний обʼєкт.

  {{< note >}}
  Група кількох контейнерів, розміщених разом в одному Podʼі є відносно складним прикладом. Ви повинні використовувати цей шаблон тільки в конкретних випадках, коли ваші контейнери тісно повʼязані.
  {{< /note >}}

Кожен Pod призначений для запуску одного екземпляра застосунку. Якщо ви хочете масштабувати свій застосунок горизонтально (щоб надати більше ресурсів, запустивши більше екземплярів), вам слід використовувати кілька Podʼів, по одному для кожного екземпляра. У Kubernetes це зазвичай називається _реплікацією_. Репліковані Podʼи створюються та керуються як група ресурсів робочих навантажень разом з їх {{< glossary_tooltip text="контролером" term_id="controller" >}}.

Ознайомтесь з [Podʼи та контролери](#pods-and-controllers) для отримання додаткової інформації про те, як Kubernetes використовує ресурси робочих навантажень та їх контролери для реалізації масштабування та автоматичного відновлення роботи застосунку.

### Як Podʼи керують кількома контейнерами {#how-pods-manage-multiple-containers}

Podʼи спроєктовано для підтримки кількох співпрацюючих процесів (таких як контейнери), які утворюють єдиний обʼєкт служби. Контейнери в Pod автоматично спільно розміщуються та плануються на тому ж фізичному або віртуальному компʼютері в кластері. Контейнери можуть спільно використовувати ресурси та залежності, спілкуватися один з одним та координувати, коли та як вони завершують роботу.

Наприклад, у вас може бути контейнер, який виконує функції вебсервера для файлів у спільному томі, та окремий "sidecar" контейнер, який оновлює ці файли з віддаленого джерела, як показано на наступній діаграмі:

{{< figure src="/images/docs/pod.svg" alt="Діаграма створення Podʼу" class="diagram-medium" >}}

Деякі Podʼи мають {{< glossary_tooltip text="контейнери ініціалізації" term_id="init-container" >}} та {{< glossary_tooltip text="контейнери застосунку" term_id="app-container" >}}. Типово, контейнери ініціалізації запускаються та завершують роботу перед тим, як почнуть працювати контейнери застосунку.

{{< feature-state for_k8s_version="v1.29" state="beta" >}}

Типово увімкнено, функція `SidecarContainers` [feature gate](/docs/reference/command-line-tools-reference/feature-gates/) дозволяє вам вказати `restartPolicy: Always` для контейнерів ініціалізації. Встановлення політики перезапуску `Always` гарантує, що контейнери ініціалізації, де ви встановили це, будуть працювати протягом усього життєвого циклу Pod. Дивіться [Контейнери sidecar та restartPolicy](/docs/concepts/workloads/pods/init-containers/#sidecar-containers-and-restartpolicy) для отримання додаткової інформації.

Podʼи можуть надавати два види спільних ресурсів для своїх підпорядкованих контейнерів: [мережу](#pod-networking) та [зберігання](#pod-storage).

## Робота з Podʼами {#working-with-pods}

Ви навряд чи створюватимете окремі Pod напряму в Kubernetes, навіть одиничні Podʼи. Це тому, що Podʼи спроєктовано бути відносно ефемерними, одноразовими обʼєктами, які можуть бути втрачені в будь-який момент. Коли Pod створено (чи це зроблено вами, чи це зроблено автоматично за допомогою {{< glossary_tooltip text="контролера" term_id="controller" >}}), новий Pod планується на виконання на {{< glossary_tooltip text="вузлі" term_id="node" >}} вашого кластера. Pod залишається на цьому вузлі до тих пір, поки він не завершить роботу, обʼєкт Pod видалено, Pod _виселено_ за відсутності ресурсів, або вузол зазнав збою.

{{< note >}}
Перезапуск контейнера в Pod не слід плутати з перезапуском Podʼу. Pod — це не процес, а середовище для запуску контейнера(ів). Pod існує до тих пір, поки його не видалено.
{{< /note >}}

Назва Podʼу має бути дійсним [DNS-піддоменом](/docs/concepts/overview/working-with-objects/names#dns-subdomain-names), але це може призвести до неочікуваних результатів для імені хоста Podʼу. Для найкращої сумісності, імʼя має відповідати більш обмеженим правилам для [DNS-мітки](/docs/concepts/overview/working-with-objects/names#dns-label-names).

### Операційна система Podʼу {#pod-os}

{{< feature-state state="stable" for_k8s_version="v1.25" >}}

Ви маєте вказати значення поля `.spec.os.name` як `linux` або `windows`, щоб вказати ОС, на якій ви хочете запустити Pod. Ці дві ОС підтримуються Kubernetes. У майбутньому цей список може бути розширений.

В Kubernetes v{{< skew currentVersion >}}, значення, яке ви встановлюєте для цього поля, не впливає на {{< glossary_tooltip text="планування" term_id="kube-scheduler" >}} Podʼів. Встановлення `.spec.os.name` допомагає однозначно ідентифікувати ОС Podʼу та використовувати його для валідації. {{< glossary_tooltip text="Kubelet" term_id="kubelet" >}} відмовляється запускати Pod, де ви вказали ОС Pod, якщо вона не збігається з операційною системою вузла, на якому працює цей kubelet.
[Стандарти безпеки Pod](/docs/concepts/security/pod-security-standards/) також використовують це поле, щоб уникнути застосування політик, які не є відповідними для цієї операційної системи.

### Podʼи та контролери {#pods-and-controllers}

Ви можете використовувати ресурси робочих навантажень для створення та керування Podʼами. Контролери ресурсів опікуються реплікацією та розгортанням Podʼів, а також автоматичним відновленням роботи застосунку в разі відмови. Наприклад, якщо Node впав, контролер помітить, що Pod на цьому вузлі перестав працювати, він створить заміну Podʼу. Планувальник поміщає Pod заміну до нового працездатного вузла.

Ось кілька прикладів ресурсів робочих наватнажень, які керують одним чи більше Podʼами:

* {{< glossary_tooltip text="Deployment" term_id="deployment" >}}
* {{< glossary_tooltip text="StatefulSet" term_id="statefulset" >}}
* {{< glossary_tooltip text="DaemonSet" term_id="daemonset" >}}

### Pod templates

Контролери ресурсів {{< glossary_tooltip text="робочих навантажень" term_id="workload" >}} створюють Pod з _pod template_ та керують цими Podʼом від вашого імені.

PodTemplate — це специфікація для створення Pod, і вона включена в ресурси робочих навантажень, такі як [Deployment](/docs/concepts/workloads/controllers/deployment/), [Job](/docs/concepts/workloads/controllers/job/) та [DaemonSet](/docs/concepts/workloads/controllers/daemonset/).

Кожен контролер ресурсів робочих навантажень використовує `PodTemplate` всередині обʼєкта робочого навантаження для створення фактичних Podʼів. `PodTemplate` є частиною бажаного стану будь-якого ресурсу робочого навантаження, який ви використовуєте для запуску вашого застосунку.

Приклад нижче — це маніфест простого Job з `template`, який запускає один контейнер. Контейнер в цьому Podʼі виводить повідомлення, а потім призупиняється.

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: hello
spec:
  template:
    # Це шаблон Podʼу
    spec:
      containers:
      - name: hello
        image: busybox:1.28
        command: ['sh', '-c', 'echo "Hello, Kubernetes!" && sleep 3600']
      restartPolicy: OnFailure
    # Кінець щаблону Podʼу
```

Зміна template або перемикання на новий template не має прямого впливу на Podʼи, які вже існують. Якщо ви змінюєте template Podʼу для ресурсу робочого навантаження, цей ресурс має створити Pod заміну, який використовує оновлений template.

Наприклад, контролер StatefulSet переконується, що запущені Pod відповідають поточному template для кожного обʼєкта StatefulSet. Якщо ви редагуєте StatefulSet, щоб змінити його template, StatefulSet починає створювати нові Pod на основі оновленого template. З часом всі старі Pod замінюються новими і оновлення завершується.

Кожен ресурс робочого навантаження реалізує власні правила для обробки змін у template Podʼу. Якщо ви хочете дізнатися більше про StatefulSet, прочитайте [Стратегія оновлення](/docs/tutorials/stateful-application/basic-stateful-set/#updating-statefulsets) в посібнику StatefulSet Basics.

На вузлах {{< glossary_tooltip term_id="kubelet" text="kubelet" >}} безпосередньо не спостерігає або керує жодними деталями щодо template Podʼу та оновлень; ці деталі абстраговані. Ця абстракція та розділення відповідальностей спрощує семантику системи та робить можливим розширення поведінки кластера без зміни наявного коду.

## Оновлення та заміна Podʼів {#pod-update-and-replacement}

Як зазначено в попередньому розділі, коли template Podʼу для ресурсу робочого навантаження змінюється, контролер створює нові Podʼи на основі оновленого template замість оновлення або латання наявних Podʼів.

Kubernetes не забороняє вам керувати Pod напряму. Ви можете оновлювати деякі поля запущеного Pod, на місці. Однак операції оновлення Pod, такі як [`patch`](/docs/reference/generated/kubernetes-api/{{< param "version" >}}/#patch-pod-v1-core) та [`replace`](/docs/reference/generated/kubernetes-api/{{< param "version" >}}/#replace-pod-v1-core), мають деякі обмеження:

* Більшість метаданих про Pod є незмінними. Наприклад, ви не можете змінити поля `namespace`, `name`, `uid` або `creationTimestamp`; поле `generation` є унікальним. Воно приймає лише оновлення, які збільшують поточне значення поля.
* Якщо `metadata.deletionTimestamp` встановлено, новий запис не може бути доданий до списку `metadata.finalizers`.
* Оновлення Pod може не змінювати поля, крім `spec.containers[*].image`, `spec.initContainers[*].image`, `spec.activeDeadlineSeconds` або `spec.tolerations`. Для `spec.tolerations` ви можете додавати лише нові записи.
* Коли ви оновлюєте `spec.activeDeadlineSeconds`, дозволені два типи оновлень:
  1. встановлення непризначеному полю позитивного числа;
  2. оновлення поля з позитивного числа на менше, невідʼємне число.

## Спільні ресурси та комунікація {#resource-sharing-and-communication}

Podʼи дозволяють контейнерам спільно використовувати ресурси та спілкуватися один з одним.

### Збереження в Podʼах {#pod-storage}

Кожен Pod може вказати набір спільних {{< glossary_tooltip text="ресурсів зберігання" term_id="volume" >}}. Всі контейнери в Pod можуть отримати доступ до спільних томів, що дозволяє цим контейнерам спільно використовувати дані. Також томи дозволяють постійним даним в Pod вижити в разі перезапуску одного з контейнерів. Дивіться [Зберігання](/docs/concepts/storage/) для отримання додаткової інформації про те, як Kubernetes реалізує спільне зберігання та робить його доступним для Podʼів.

### Мережі та Pod {#pod-networking}

Кожен Pod отримує власну унікальну IP-адресу для кожного сімейства адрес. Кожен контейнер в Pod використовує спільний простір імен мережі, включаючи IP-адресу та мережеві порти. В межах Pod (і **тільки** там) контейнери, які належать до Pod, можуть спілкуватися один з одним, використовуючи `localhost`. Коли контейнери в Pod спілкуються з іншими обʼєктами _по за Podʼом_, вони повинні координуватись, як вони використовують спільні мережеві ресурси (такі як порти). В межах Pod контейнери спільно використовують IP-адресу та порти, і можуть знаходити один одного через `localhost`. Контейнери в різних Podʼах мають власні IP-адреси та не можуть спілкуватися за допомогою міжпроцесового звʼязку ОС без спеціальної конфігурації. Контейнери, які хочуть взаємодіяти з контейнером, що працює в іншому Pod, можуть використовувати IP-мережу для комунікації.

Контейнери в Pod бачать системне імʼя хоста таким самим, як і вказане `name` для Pod. Більше про це ви можете прочитати в розділі [мережі](/docs/concepts/cluster-administration/networking/).

## Привілейований режим контейнерів {#privileged-mode-for-containers}

{{< feature-state for_k8s_version="v1.26" state="stable" >}}

{{< note >}}
Ваше {{< glossary_tooltip text="середовище виконання контейнерів" term_id="container-runtime" >}} повинно підтримувати концепцію привілейованих контейнерів, щоб цей параметр був релевантним.
{{< /note >}}

Будь-який контейнер в Pod може працювати в привілейованому режимі, щоб використовувати адміністративні можливості операційної системи, які інакше були б недоступні. Це доступно як для Windows, так і для Linux.

### Привілейовані контейнери Linux {#linux-privileged-containers}

В Linux будь-який контейнер в Pod може ввімкнути привілейований режим, використовуючи прапорець `privileged` (Linux) в [контексті безпеки](/docs/tasks/configure-pod-container/security-context/) специфікації контейнера. Це корисно для контейнерів, які хочуть використовувати адміністративні можливості операційної системи, такі як маніпулювання мережевим стеком або доступ до апаратних пристроїв.

### Привілейовані контейнери Windows {#windows-privileged-containers}

{{< feature-state for_k8s_version="v1.26" state="stable" >}}

У Windows ви можете створити [Windows HostProcess pod](/docs/tasks/configure-pod-container/create-hostprocess-pod), встановивши прапорець `windowsOptions.hostProcess` в контексті безпеки специфікації Pod. Всі контейнери в цих Pod повинні працювати як контейнери Windows HostProcess. HostProcess Pod працюють безпосередньо на хості та також можуть використовуватися для виконання адміністративних завдань, як це робиться з Linux привілейованими контейнерами.

## Статичні Podʼи {#static-pods}

{{< feature-state for_k8s_version="v1.22" state="stable" >}}

_Static Pods_ керуються безпосередньо демоном kubelet на конкретному вузлі, без спостереження з боку {{< glossary_tooltip text="сервера API" term_id="kube-apiserver" >}}. У той час як більшість Podʼів керуються панеллю управління (наприклад, {{< glossary_tooltip text="Deployment" term_id="deployment" >}}), для статичних Podʼів kubelet безпосередньо наглядає за кожним статичним Pod (та перезапускає його, якщо він падає).

Статичні Podʼи завжди привʼязані до одного {{< glossary_tooltip term_id="kubelet" text="Kubeletʼу" >}} на конкретному вузлі. Основне використання статичних Podʼів — це запуск самостійної панелі управління: іншими словами, використання kubelet для нагляду за окремими [компонентами панелі управління](/docs/concepts/overview/components/#control-plane-components).

Kublet автоматично намагається створити {{< glossary_tooltip text="mirror Pod" term_id="mirror-pod" >}} на сервері API Kubernetes для кожного статичного Pod. Це означає, що Pod, які працюють на вузлі, видно на сервері API, але ними не можна керувати звідти. Дивіться [Створення статичних Podʼів](/docs/tasks/configure-pod-container/static-pod) для отримання додаткової інформації.

{{< note >}}
Розділ `spec` статичного Pod не може посилатися на інші API-обʼєкти (наприклад, {{< glossary_tooltip text="ServiceAccount" term_id="service-account" >}}, {{< glossary_tooltip text="ConfigMap" term_id="configmap" >}}, {{< glossary_tooltip text="Secret" term_id="secret" >}} тощо).
{{< /note >}}

## Перевірки контейнерів {#container-probes}

_Probe_ — це діагностика, яку періодично виконує kubelet на контейнері. Для виконання діагностики kubelet може використовувати різні дії:

* `ExecAction` (виконується за допомогою процесу виконання контейнера)
* `TCPSocketAction` (перевіряється безпосередньо the kubelet)
* `HTTPGetAction` (перевіряється безпосередньо kubelet)

Ви можете дізнатися більше про [перевірки](/docs/concepts/workloads/pods/pod-lifecycle/#container-probes) в документації про життєвий цикл Podʼів

## {{% heading "whatsnext" %}}

* Дізнайтесь про [життєвий цикл Podʼів](/docs/concepts/workloads/pods/pod-lifecycle/).
* Дізнайтесь про [RuntimeClass](/docs/concepts/containers/runtime-class/) та як ви можете використовувати його для налаштування різних Pod з різними конфігураціями середовища виконання контейнера.
* Дізнайтесь про [PodDisruptionBudget](/docs/concepts/workloads/pods/disruptions/) та як ви можете використовувати його для керування доступністю застосунку під час збоїв.
* Pod є ресурсом найвищого рівня в Kubernetes REST API. Обʼєкт {{< api-reference page="workload-resources/pod-v1" >}} детально описує його.
* [The Distributed System Toolkit: Patterns for Composite Containers](/blog/2015/06/the-distributed-system-toolkit-patterns/) пояснює загальні макети для Pod з більш ніж одним контейнером.
* Дізнайтесь про [Топологію обмежень розподілу Podʼів](/docs/concepts/scheduling-eviction/topology-spread-constraints/)

Для розуміння контексту того, чому Kubernetes обгортає загальний API Pod іншими ресурсами (такими як {{< glossary_tooltip text="StatefulSets" term_id="statefulset" >}} або {{< glossary_tooltip text="Deployments" term_id="deployment" >}}), ви можете прочитати про попередні роботи, включаючи:

* [Aurora](https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema)
* [Borg](https://research.google.com/pubs/pub43438.html)
* [Marathon](https://mesosphere.github.io/marathon/docs/rest-api.html)
* [Omega](https://research.google/pubs/pub41684/)
* [Tupperware](https://engineering.fb.com/data-center-engineering/tupperware/).
