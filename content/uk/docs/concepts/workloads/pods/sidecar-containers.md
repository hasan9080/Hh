---
title: Контейнери sidecar
content_type: concept
weight: 50
---

{{< feature-state for_k8s_version="v1.29" state="beta" >}}

Контейнери sidecar — це додаткові контейнери, які працюють разом із основним контейнером застосунку всередині одного {{< glossary_tooltip text="Podʼа" term_id="pod" >}}. Ці контейнери використовуються для розширення чи покращення функціональності основного контейнера застосунку, надаючи додаткові служби чи функціональність, такі як логування, моніторинг, безпеку або синхронізацію даних, не змінюючи безпосередньо код основного застосунку.

## Увімкнення контейнерів sidecar {#enabling-sidecar-containers}

У Kubernetes 1.29, стандартно увімкнено [feature gate](/docs/reference/command-line-tools-reference/feature-gates/) з іменем
`SidecarContainers`, який дозволяє вам вказати `restartPolicy` для контейнерів, перерахованих в полі `initContainers` Podʼа. Ці контейнери _sidecar_, які можна перезапускати, незалежні від [контейнерів ініціалізації](/docs/concepts/workloads/pods/init-containers/) та основного контейнера застосунку всередині одного Podʼа. Їх можна запускати, зупиняти чи перезапускати
без впливу на основний контейнер застосунку та інші контейнери ініціалізації.

## Контейнери sidecar та життєвий цикл Podʼа {#sidecar-containers-and-pod-lifecycle}

Якщо контейнер ініціалізації створено з параметром `restartPolicy`, встановленим на `Always`, він розпочне роботу і залишиться запущеним протягом усього життя Podʼа. Це може бути корисно для запуску служб підтримки, відокремлених від основних контейнерів застосунку.

Якщо для цього контейнера ініціалізації вказано `readinessProbe`, результат буде використовуватися для визначення стану `ready` Podʼа.

Оскільки ці контейнери визначені як контейнери ініціалізації, вони користуються тими ж гарантіями порядку та послідовності, що й інші контейнери ініціалізації, що дозволяє їх змішувати з іншими контейнерами ініціалізації в складні потоки ініціалізації Podʼа.

В порівнянні зі звичайними контейнерами ініціалізації, контейнери, визначені в `initContainers`, продовжують роботу після їх запуску. Це важливо, коли в `.spec.initContainers` для Podʼа є більше одного запису. Після запуску контейнера ініціалізації типу sidecar (kubelet встановлює статус `started` для цього контейнера в `true`), kubelet запускає наступний контейнер ініціалізації з упорядкованого списку `.spec.initContainers`. Цей статус стає true через те, що в контейнері працює процес і немає визначеного `startupProbe`, або внаслідок успішного виконання `startupProbe`.

Ось приклад Deployment із двома контейнерами, один з яких — це контейнер sidecar:

{{% code_sample language="yaml" file="application/deployment-sidecar.yaml" %}}

Ця функція також корисна для запуску задач із контейнерами sidecar, оскільки контейнер sidecar не завадить задачі завершити роботу після завершення роботи основного контейнера.

Ось приклад задачі із двома контейнерами, один з яких — це контейнер sidecar:

{{% code_sample language="yaml" file="application/job/job-sidecar.yaml" %}}

## Відмінності від звичайних контейнерів {#differences-from-regulr-containers}

Контейнери sidecar працюють поруч зі звичайними контейнерами в одному Podʼі. Однак вони не виконують основну логіку застосунку; замість цього вони надають додатковий функціонал основному застосунку.

Контейнери sidecar мають власні незалежні життєві цикли. Їх можна запускати, зупиняти та перезапускати незалежно від звичайних контейнерів. Це означає, що ви можете оновлювати, масштабувати чи обслуговувати контейнери sidecar, не впливаючи на основний застосунок.

Контейнери sidecar ділять той самий простір імен мережі та сховища з основним контейнером. Це спільне розташування дозволяє їм тісно взаємодіяти та спільно використовувати ресурси.

## Відмінності від контейнерів ініціалізації {#differences-from-init-containers}

Контейнери sidecar працюють поруч із основним контейнером, розширюючи його функціональність та надаючи додаткові служби.

Контейнери sidecar працюють паралельно з основним контейнером застосунку. Вони активні протягом усього життєвого циклу Podʼа та можуть бути запущені та зупинені незалежно від основного контейнера. На відміну від [контейнерів ініціалізації](/docs/concepts/workloads/pods/init-containers/), контейнери sidecar підтримують [проби](/docs/concepts/workloads/pods/pod-lifecycle/#types-of-probe), щоб контролювати їхній життєвий цикл.

Ці контейнери можуть взаємодіяти безпосередньо з основними контейнерами застосунків, спільно використовуючи той самий простір імен мережі, файлову систему та змінні оточення. Вони тісно співпрацюють, надаючи додатковий функціонал.

## Спільне використання ресурсів всередині контейнерів {#resource-sharing-within-containers}

{{< comment >}}
Цей розділ також присутній на сторінці [контейнерів ініціалізації](/docs/concepts/workloads/pods/init-containers/).
Якщо ви редагуєте цей розділ, змініть обидва місця.
{{< /comment >}}

З урахуванням порядку виконання контейнерів ініціалізації, обслуговування та застосунків застосовуються наступні правила
використання ресурсів:

* Найвищий запит чи обмеження будь-якого конкретного ресурсу, визначеного у всіх контейнерах ініціалізації, вважається _ефективним запитом/обмеженням ініціалізації_. Якщо для будь-якого ресурсу не вказано обмеження, це вважається найвищим обмеженням.
* _Ефективний запит/обмеження Pod\у_ для ресурсу — більше з:
  * сума всіх запитів/обмежень контейнерів застосунків для ресурсу
  * ефективний запит/обмеження для ініціалізації для ресурсу
* Планування виконується на основі ефективних запитів/обмежень, що означає, що контейнери ініціалізації можуть резервувати ресурси для ініціалізації, які не використовуються протягом життя Podʼа.
* Рівень якості обслуговування (QoS), _рівень QoS Podʼа_ — є рівнем QoS як для контейнерів ініціалізації, так і для контейнерів застосунків.

Обмеження та ліміти застосовуються на основі ефективного запиту та
ліміту Podʼа.

cgroups рівня Podʼа базуються на ефективному запиті та ліміті Podʼа, так само як і планувальник.

## {{% heading "whatsnext" %}}

* Прочитайте блог-пост про [нативні контейнери sidecar](/blog/2023/08/25/native-sidecar-containers/).
* Прочитайте про [створення Podʼа, який має контейнер ініціалізації](/docs/tasks/configure-pod-container/configure-pod-initialization/#create-a-pod-that-has-an-init-container).
* Дізнайтеся про [види проб](/docs/concepts/workloads/pods/pod-lifecycle/#types-of-probe): liveness, readiness, startup probe.
* Дізнайтеся про [накладні витрати роботи Podʼа](/docs/concepts/scheduling-eviction/pod-overhead/).
