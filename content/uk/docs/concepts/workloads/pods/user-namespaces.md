---
title: Простори імен користувачів 
aka:
  - User Namespaces
reviewers:
content_type: concept
weight: 160
min-kubernetes-server-version: v1.25
---

<!-- огляд -->
{{< feature-state for_k8s_version="v1.25" state="alpha" >}}

Ця сторінка пояснює, як використовуються простори імен користувачів у Podʼах Kubernetes. Простір імен користувача ізолює користувача, який працює всередині контейнера, від користувача на хості.

Процес, який працює як root в контейнері, може працювати як інший (не-root) користувач на хості; іншими словами, процес має повні привілеї для операцій всередині простору користувача, але не має привілеїв для операцій за його межами.

Ви можете використовувати цю функцію, щоб зменшити можливий збиток, який може заподіяти скомпрометований контейнер хосту або іншим Podʼам на тому ж вузлі. Є [кілька вразливостей безпеки][KEP-vulns], які оцінено як **ВИСОКІ** або **КРИТИЧНІ**, і які не можна було б використати при активних просторах користувачів. Передбачається, що простір користувачів також буде запобігати деяким майбутнім вразливостям.

[KEP-vulns]: https://github.com/kubernetes/enhancements/tree/217d790720c5aef09b8bd4d6ca96284a0affe6c2/keps/sig-node/127-user-namespaces#motivation

<!-- тіло -->
## {{% heading "prerequisites" %}}

{{% thirdparty-content %}}

Це функція, доступна лише для Linux, і потребує підтримки в Linux для монтування idmap на використовуваних файлових системах. Це означає:

* На вузлі файлова система, яку ви використовуєте для `/var/lib/kubelet/pods/`, або спеціальна тека, яку ви конфігуруєте для цього, повинна підтримувати монтування idmap.
* Всі файлові системи, які використовуються в томах Podʼа, повинні підтримувати монтування idmap.

На практиці це означає, що вам потрібне ядро Linux принаймні версії 6.3, оскільки tmpfs почав підтримувати монтування idmap у цій версії. Це зазвичай потрібно, оскільки кілька функцій Kubernetes використовують tmpfs (токен облікового запису служби, який монтується типово, використовує tmpfs, аналогічно Secrets використовують tmpfs та інше).

Деякі популярні файлові системи, які підтримують монтування idmap в Linux 6.3, — це: btrfs, ext4, xfs, fat, tmpfs, overlayfs.

Крім того, підтримка необхідна в {{< glossary_tooltip text="середовищі виконання контейнерів" term_id="container-runtime" >}} для використання цієї функції з Podʼами Kubernetes:

* CRI-O: версія 1.25 (і пізніше) підтримує простори користувачів для контейнерів.

containerd v1.7 несумісний із підтримкою userns в Kubernetes v1.27 по v{{< skew latestVersion >}}. Kubernetes v1.25 і v1.26 використовували попередню реалізацію, яка **є** сумісною з containerd v1.7 з точки зору підтримки userns. Якщо ви використовуєте версію Kubernetes, відмінну від {{< skew currentVersion >}}, перевірте документацію для цієї версії Kubernetes для найбільш актуальної інформації. Якщо є новіша версія containerd, ніж v1.7, яка доступна для використання, також перевірте документацію containerd щодо інформації про сумісність.

Стан підтримки просторів користувачів в cri-dockerd відстежується у [тікеті][CRI-dockerd-issue] на GitHub.

[CRI-dockerd-issue]: https://github.com/Mirantis/cri-dockerd/issues/74

## Вступ {#introduction}

Простори користувачів — це функція Linux, яка дозволяє зіставляти користувачів у контейнері з користувачами на хості. Крім того, можливості, наданні Pod в просторі користувача, є дійсними лише в просторі та не виходять за його межі.

Pod може обрати використовувати простори користувачів, встановивши поле `pod.spec.hostUsers` в `false`.

Kubelet вибере host UID/GID, до якого зіставлено Pod, і зробить це так, щоб гарантувати, що жоден з Podʼів на одному вузлі не використовує те саме зіставлення.

Поля `runAsUser`, `runAsGroup`, `fsGroup` тощо в `pod.spec` завжди звертаються до користувача всередині контейнера.

Дійсні UID/GID, коли ця функція активована, є у діапазоні 0-65535. Це стосується файлів та процесів (`runAsUser`, `runAsGroup` і т. д.).

Файли з UID/GID за межами цього діапазону будуть вважатися належними переповненню ID, яке зазвичай дорівнює 65534 (налаштовано в `/proc/sys/kernel/overflowuid` та `/proc/sys/kernel/overflowgid`). Однак їх неможливо змінити, навіть якщо запущено як user/group 65534.

Більшість застосунків, які потребують запуску з правами root, але не мають доступу до інших просторів імен хоста чи ресурсів, повинні продовжувати працювати без змін, якщо простори користувачів активовано.

## Розуміння просторів користувачів для Podʼів {#pods-and-userns}

Кілька середовищ виконання контейнерів із їхньою типовою конфігурацією (таких як Docker Engine, containerd, CRI-O) використовують простори імен Linux для ізоляції. Існують інші технології, які також можна використовувати з цими середовищами (наприклад, Kata Containers використовує віртуальні машини замість просторів імен Linux). Ця стосується середовищ виконання контейнерів, які використовують простори імен Linux для ізоляції.

При стандартному створенні Podʼа використовуються різні нові простори імен для ізоляції: мережевий простір імен для ізоляції мережі контейнера, простір імен PID для ізоляції виду процесів і т.д. Якщо використовується простір користувачів, це ізолює користувачів у контейнері від користувачів на вузлі.

Це означає, що контейнери можуть працювати як root та зіставлятись з не-root користувачами на хості. Всередині контейнера процес буде вважати себе root (і, отже, інструменти типу `apt`, `yum`, ін. працюватимуть нормально), тоді як насправді процес не має привілеїв на хості. Ви можете перевірити це, наприклад, якщо ви перевірите, як користувач запущений у контейнері, виконавши `ps aux` з хосту. Користувач, якого показує `ps`, не той самий, що і користувач, якого ви бачите, якщо ви виконаєте команду `id` всередині контейнера.

Ця абстракція обмежує те, що може трапитися, наприклад, якщо контейнер вдасться перетече на хост. Оскільки контейнер працює як не-привілейований користувач на хості, обмежено те, що він може зробити на хості.

Крім того, оскільки користувачі в кожному Podʼі будуть зіставлені з різними користувачами на хості, обмежено те, що вони можуть зробити з іншими Podʼами.

Можливості, надані Podʼу, також обмежуються простором користувача Podʼу і в основному є недійсними поза межами його простору, а деякі навіть абсолютно нечинні. Ось два приклади:

* `CAP_SYS_MODULE` не має жодного ефекту, якщо зіставлено в Podʼі з використанням просторів користувачів, Pod не може завантажити модулі ядра.
* `CAP_SYS_ADMIN` обмежений простором користувача Podʼу та є недійсним поза його межами.

Без використання просторів користувачів контейнер, який працює як root, у разі втечі контейнера, має привілеї root на вузлі. І якщо контейнеру надано деякі можливості, ці можливості є дійсними на хості. Цього не відбувається, коли ми використовуємо простори користувачів.

Якщо ви хочете дізнатися більше подробиць про те, що змінюється при використанні просторів користувачів, дивіться `man 7 user_namespaces`.

## Налаштування вузла для підтримки просторів користувачів {#set-up-a-node-to-support-user-namespaces}

Рекомендується, щоб файли та процеси хосту використовували UID/GID в діапазоні від 0 до 65535.

Kubelet призначить UID/GID вище цього для Podʼів. Таким чином, щоб
гарантувати максимальну ізоляцію, UID/GID, використовувані файлами
та процесами хосту, повинні бути в діапазоні від 0 до 65535.

Зверніть увагу, що ця рекомендація є важливою для зменшення впливу CVE, такого як [CVE-2021-25741][CVE-2021-25741], де потенційно Pod може читати довільні файли на хостах. Якщо UID/GID Podʼу та хосту не перекриваються, обмежено те, що може зробити Pod: UID/GID Podʼа не збігається із власником/групою файлів хосту.

[CVE-2021-25741]: https://github.com/kubernetes/kubernetes/issues/104980

## Інтеграція з перевірками безпеки доступу в Podʼи

{{< feature-state state="alpha" for_k8s_version="v1.29" >}}

Для Podʼів Linux, які увімкнули простори користувачів, Kubernetes послаблює застосування [Стандартів безпеки Podʼу](/docs/concepts/security/pod-security-standards) контрольованим способом. Цю поведінку можна контролювати за допомогою [feature gate](/docs/reference/command-line-tools-reference/feature-gates/)
`UserNamespacesPodSecurityStandards`, що дозволяє раннє включення для кінцевих користувачів. Адміністраторам слід забезпечити увімкнення просторів користувачів на всіх вузлах в межах кластера при використанні feature gate.

Якщо ви увімкнете відповідний feature gate та створите Pod, який використовує простори користувачів, yfcnegys поля не будуть обмежені навіть в контекстах, які застосовують _Baseline_ чи _Restricted_ Podʼа. Це не становить проблему безпеки, оскільки `root` всередині Podʼа з просторами користувачів фактично посилається на користувача всередині контейнера, який ніколи не зіставляється з привілейованим користувачем на хості. Ось список полів, які **не** перевіряються для Podʼів в цих обставинах:

* `spec.securityContext.runAsNonRoot`
* `spec.containers[*].securityContext.runAsNonRoot`
* `spec.initContainers[*].securityContext.runAsNonRoot`
* `spec.ephemeralContainers[*].securityContext.runAsNonRoot`
* `spec.securityContext.runAsUser`
* `spec.containers[*].securityContext.runAsUser`
* `spec.initContainers[*].securityContext.runAsUser`
* `spec.ephemeralContainers[*].securityContext.runAsUser`

## Обмеження {#limitations}

При використанні просторів користувачів для Podʼа заборонено використовувати інші простори імен хосту. Зокрема, якщо ви встановите `hostUsers: false`, ви не маєте права встановлювати будь-яке з наступного:

* `hostNetwork: true`
* `hostIPC: true`
* `hostPID: true`

## {{% heading "whatsnext" %}}

* Подивіться [Використання простору користувача в Podʼах](/docs/tasks/configure-pod-container/user-namespaces/)
